<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.2.8 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc toc="yes"?>

<rfc ipr="trust200902" docName="draft-ietf-lpwan-ipv6-static-context-hc-10" category="info">

  <front>
    <title abbrev="LPWAN SCHC">LPWAN Static Context Header Compression (SCHC) and fragmentation for IPv6 and UDP</title>

    <author initials="A." surname="Minaburo" fullname="Ana Minaburo">
      <organization>Acklio</organization>
      <address>
        <postal>
          <street>2bis rue de la Chataigneraie</street>
          <city>35510 Cesson-Sevigne Cedex</city>
          <country>France</country>
        </postal>
        <email>ana@ackl.io</email>
      </address>
    </author>
    <author initials="L." surname="Toutain" fullname="Laurent Toutain">
      <organization>IMT-Atlantique</organization>
      <address>
        <postal>
          <street>2 rue de la Chataigneraie</street> <street>CS 17607</street>
          <city>35576 Cesson-Sevigne Cedex</city>
          <country>France</country>
        </postal>
        <email>Laurent.Toutain@imt-atlantique.fr</email>
      </address>
    </author>
    <author initials="C." surname="Gomez" fullname="Carles Gomez">
      <organization>Universitat Politècnica de Catalunya</organization>
      <address>
        <postal>
          <street>C/Esteve Terradas, 7</street> <street>08860 Castelldefels</street>
          <country>Spain</country>
        </postal>
        <email>carlesgo@entel.upc.edu</email>
      </address>
    </author>

    <date year="2018" month="February" day="27"/>

    
    <workgroup>lpwan Working Group</workgroup>
    

    <abstract>


<t>This document defines the Static Context Header Compression (SCHC) framework, which provides header compression and 
fragmentation functionality. SCHC has been tailored for Low Power Wide Area Networks (LPWAN).</t>

<t>SCHC compression is based on a common static context stored in LPWAN devices and in the network. This document applies SCHC 
compression to IPv6/UDP headers. This document also specifies a fragmentation and reassembly mechanism that is used to 
support the IPv6 MTU requirement over LPWAN technologies. Fragmentation is mandatory for IPv6 datagrams that, after SCHC 
compression or when it has not been possible to apply such compression, still exceed the layer two maximum payload size.</t>

<t>The SCHC header compression mechanism is independent of the specific LPWAN technology over which it will be used.
Note that this document defines generic functionality. This document purposefully offers flexibility with regard to parameter 
settings and mechanism choices, that are expected to be made in other, technology-specific, documents.</t>



    </abstract>


  </front>

  <middle>


<section anchor="Introduction" title="Introduction">

<t>This document defines a header compression scheme and fragmentation functionality, both specially tailored for Low Power Wide Area Networks (LPWAN).</t>

<t>Header compression is needed to efficiently bring Internet connectivity to the node
within an LPWAN network. Some LPWAN networks properties can be exploited to get an efficient header compression:</t>

<t><list style="symbols">
  <t>The topology is star-oriented which means that all packets follow the same path. For the necessity of this draft, the architecture is simple and is described as Devices (Dev) exchanging information with LPWAN Application Servers (App) through Network Gateways (NGW).</t>
  <t>The traffic flows can be known in advance since devices embed built-in applications. New applications cannot be easily installed in LPWAN devices, as they would in computers or smartphones.</t>
</list></t>

<t>The Static Context Header Compression (SCHC) is defined for this environment.
SCHC uses a context, where header information is kept in the header format order. This context is
static: the values of the header fields do not change over time. This avoids
complex resynchronization mechanisms, that would be incompatible
with LPWAN characteristics. In most cases, a small context identifier is enough to represent the full IPv6/UDP headers. 
The SCHC header compression mechanism is independent of the specific LPWAN technology over which it is used.</t>

<t>LPWAN technologies impose some strict limitations on traffic. For instance, 
devices are sleeping most of the time and may receive data during short periods
of time after transmission to preserve battery. LPWAN technologies are also characterized,
among others, by a very reduced data unit and/or payload size
<xref target="I-D.ietf-lpwan-overview"/>.  However, some of these technologies
do not provide fragmentation functionality, therefore the only option for them to support the IPv6 MTU requirement of 1280 
bytes <xref target="RFC2460"/> is to use a fragmentation protocol at the adaptation layer, below IPv6. 
In response to this need, this document also defines a fragmentation/reassembly
mechanism, which supports the IPv6 MTU requirement over LPWAN
technologies. Such functionality has been designed under the assumption that data unit out-of-sequence delivery will not 
happen between the entity performing fragmentation and the entity performing reassembly.</t>

<t>Note that this document defines generic functionality and purposefully offers flexibility with regard to parameter settings 
and mechanism choices, that are expected to be made in other, technology-specific documents (e.g. {{I-D.zuniga-lpwan-schc-
over-sigfox}}, <xref target="I-D.petrov-lpwan-ipv6-schc-over-lorawan"/>).</t>

</section>
<section anchor="LPWAN-Archi" title="LPWAN Architecture">

<t>LPWAN technologies have similar network architectures but different
terminology. We can identify different types of entities in a
typical LPWAN network, see <xref target="Fig-LPWANarchi"/>:</t>

<t>o  Devices (Dev) are the end-devices or hosts (e.g. sensors,
      actuators, etc.). There can be a very high density of devices per radio gateway.</t>

<t>o  The Radio Gateway (RGW), which is the end point of the constrained link.</t>

<t>o  The Network Gateway (NGW) is the interconnection node between the Radio Gateway and the Internet.</t>

<t>o  LPWAN-AAA Server, which controls the user authentication and the
      applications.</t>

<t>o  Application Server (App)</t>

<figure title="LPWAN Architecture" anchor="Fig-LPWANarchi"><artwork><![CDATA[
                                           +------+
 ()   ()   ()       |                      |LPWAN-|
  ()  () () ()     / \       +---------+   | AAA  |
() () () () () () /   \======|    ^    |===|Server|  +-----------+
 ()  ()   ()     |           | <--|--> |   +------+  |APPLICATION|
()  ()  ()  ()  / \==========|    v    |=============|   (App)   |
  ()  ()  ()   /   \         +---------+             +-----------+
 Dev        Radio Gateways         NGW

]]></artwork></figure>

</section>
<section anchor="terminology" title="Terminology">
<t>This section defines the terminology and acronyms used in this document.</t>

<t><list style="symbols">
  <t>Abort. A fragment format to signal the other end-point that the on-going fragment transmission is stopped and finished.</t>
  <t>ACK (Acknowledgment). A fragment format used to report the success or unsuccess reception of a set of fragments.</t>
  <t>All-0. The fragment format for the last frame of a window that is not the last one of a packet (see Window in this 
glossary).</t>
  <t>All-1. The fragment format for the last frame of the packet.</t>
  <t>All-0 empty. An All-0 fragment without a payload. It is used to request the ACK with the encoded Bitmap when the 
Retransmission Timer expires, in a window that is not the last one of a packet.</t>
  <t>All-1 empty. An All-1 fragment without a payload. It is used to request the ACK with the encoded Bitmap when the 
Retransmission Timer expires in the last window of a packet.</t>
  <t>App: LPWAN Application. An application sending/receiving IPv6 packets to/from the Device.</t>
  <t>APP-IID: Application Interface Identifier. Second part of the IPv6 address that identifies the application server 
interface.</t>
  <t>Bi: Bidirectional, a rule entry that applies to headers of packets travelling in both directions (Up and Dw).</t>
  <t>Bitmap: a field of bits in an acknowledgment message that tells the sender which fragments of a window were correctly 
received.</t>
  <t>C: Checked bit. Used in an acknowledgment (ACK) header to determine if the MIC locally computed by the receiver matches (1) 
the received MIC or not (0).</t>
  <t>CDA: Compression/Decompression Action. Describes the reciprocal pair of actions that are performed at the compressor to 
compress a header field and at the decompressor to recover the original header field value.</t>
  <t>Compress Residue. The bytes that need to be sent after applying the SCHC compression over each header field</t>
  <t>Context: A set of rules used to compress/decompress headers.</t>
  <t>Dev: Device. A node connected to the LPWAN. A Dev may implement SCHC.</t>
  <t>Dev-IID: Device Interface Identifier. Second part of the IPv6 address that identifies the device interface.</t>
  <t>DI: Direction Indicator. This field tells which direction of packet travel (Up, Dw or Bi) a rule applies to. This allows 
for assymmetric processing.</t>
  <t>DTag: Datagram Tag. This fragmentation header field is set to the same value for all fragments carrying the same IPv6 
datagram.</t>
  <t>Dw: Dw: Downlink direction for compression/decompression in both sides, from SCHC C/D in the network to SCHC C/D in the 
Dev.</t>
  <t>FCN: Fragment Compressed Number. This fragmentation header field carries an efficient representation of a larger-sized 
fragment number.</t>
  <t>Field Description. A line in the Rule Table.</t>
  <t>FID: Field Identifier. This is an index to describe the header fields in a Rule.</t>
  <t>FL: Field Length is the length of the field in bits for fixed values or a type (variable, token length, …) for length 
unknown at the rule creation. The length of a header field is defined in the specific protocol standard.</t>
  <t>FP: Field Position is a value that is used to identify the position where each instance of a field appears in the header.</t>
  <t>Fragment: A data unit that carries a subset of a SCHC packet. Fragmentation is needed when the size of a SCHC packet 
exceeds the available payload size of the underlying L2 technology data unit.</t>
  <t>IID: Interface Identifier. See the IPv6 addressing architecture <xref target="RFC7136"/></t>
  <t>Inactivity Timer. A timer used after receiving a fragment to detect when there is an error and there is no possibility to continue an on-going fragmented packet transmission.</t>
  <t>L2: Layer two. The immediate lower layer SCHC interfaces with. It is provided by an underlying LPWAN technology.</t>
  <t>MIC: Message Integrity Check.  A fragmentation header field computed over an IPv6 packet before fragmentation, used for error detection after IPv6 packet reassembly.</t>
  <t>MO: Matching Operator. An operator used to match a value contained in a header field with a value contained in a Rule.</t>
  <t>Retransmission Timer. A timer used by the fragment sender during an on-going fragmented packet transmission to detect possible link errors when waiting for a possible incoming ACK.</t>
  <t>Rule: A set of header field values.</t>
  <t>Rule entry: A row in the rule that describes a header field.</t>
  <t>Rule ID: An identifier for a rule, SCHC C/D in both sides share the same Rule ID for a specific packet. A set of Rule IDs 
are used to support fragmentation functionality.</t>
  <t>SCHC C/D: Static Context Header Compression Compressor/Decompressor. A mechanism used in both sides, at the Dev and at the 
network to achieve Compression/Decompression of headers. SCHC C/D uses SCHC rules to perform compression and decompression.</t>
  <t>SCHC packet: A packet (e.g. an IPv6 packet) whose header has been compressed as per the header compression mechanism 
defined in this document. If the header compression process is unable to actually compress the packet header, the packet with 
the uncompressed header is still called a SCHC packet (in this case, a Rule ID is used to indicate that the packet header has 
not been compressed).</t>
  <t>TV: Target value. A value contained in the Rule that will be matched with the value of a header field.</t>
  <t>Up: Uplink direction for compression/decompression in both sides, from the Dev SCHC C/D to the network SCHC C/D.</t>
  <t>W: Window bit. A fragment header field used in Window mode (see section 5), which carries the same value for all fragments 
of a window.</t>
  <t>Window:  A subset of the fragments needed to carry a packet (see section 5)</t>
</list></t>

</section>
<section anchor="schc-overview" title="SCHC overview">

<t>SCHC can be abstracted as an adaptation layer below IPv6 and the underlying LPWAN technology. SCHC that comprises two 
sublayers (i.e. the Compression sublayer and the Fragmentation sublayer), as shown in <xref target="Fig-IntroLayers"/>.</t>

<figure title="Protocol stack comprising IPv6, SCHC and an LPWAN technology" anchor="Fig-IntroLayers"><artwork><![CDATA[
 
             +----------------+
             |      IPv6      | 
          +- +----------------+            
          |  |   Compression  |  
    SCHC <   +----------------+   
          |  |  Fragmentation |
          +- +----------------+         
             |LPWAN technology|
             +----------------+ 

]]></artwork></figure>

<t>As per this document, when a packet (e.g. an IPv6 packet) needs to be transmitted, header compression is first applied to the 
packet. The resulting packet after header compression (whose header may actually be smaller than that of the original packet 
or not) is called a SCHC packet. Subsequently, and if the SCHC packet size exceeds the layer 2 (L2) MTU, fragmentation is 
then applied to the SCHC packet. This process is illustrated by <xref target="Fig-Operations"/></t>

<figure title="SCHC operations from a sender point of view: header compression and fragmentation" anchor="Fig-Operations"><artwork><![CDATA[
 
       A packet (e.g. an IPv6 packet)
                  |
                  V   
    +------------------------------+
    |SCHC Compression/Decompression|
    +------------------------------+            
                  |
              SCHC packet              
                  |
                  V 
        +------------------+    
        |SCHC Fragmentation|  (if needed)
        +------------------+     
                  |
                  V     
           SCHC Fragment(s) (if needed)


]]></artwork></figure>

</section>
<section anchor="rule-id" title="Rule ID">

<t>Rule ID are identifiers used to select either the correct context to be used for Compression/Decompression functionalities or 
for Fragmentation or after trying to do SCHC C/D and fragmentation the packet is sent as is. The size of the Rule ID is not 
specified in this document, as it is implementation-specific and can vary according to the LPWAN technology and the number of 
Rules, among others.</t>

<t>The Rule IDs identified are:
* In the SCHC C/D context the Rule used to keep the Field Description of the header packet.</t>

<t><list style="symbols">
  <t>In SCHC Fragmentation to identify the specific modes and settings. In bidirectional fragmentation at least two Rules Id are 
needed.</t>
  <t>And at least one Rule ID may be reserved to the case where no SCHC C/D nor SCHC fragmentation were possible.</t>
</list></t>

</section>
<section anchor="static-context-header-compression" title="Static Context Header Compression">

<t>In order to perform header compression, this document defines a mechanism called Static Context Header Compression (SCHC), 
which is based on using context, i.e. a set of rules to compress or decompress headers. SCHC avoids context
synchronization, which is the most bandwidth-consuming operation in
other header compression mechanisms such as RoHC <xref target="RFC5795"/>. Since the nature of packets are highly predictable in LPWAN
networks, static contexts may be stored beforehand to omit transmitting some information over the air.
The contexts must be stored at both ends, and they can either be learned by a provisioning protocol, by out of band means, 
or they can be pre-provisioned. The way the contexts are provisioned on both ends is out of the scope of this document.</t>

<figure title="Architecture" anchor="Fig-archi"><artwork><![CDATA[
     Dev                                                 App
+----------------+                                  +--------------+
| APP1 APP2 APP3 |                                  |APP1 APP2 APP3|
|                |                                  |              |
|       UDP      |                                  |     UDP      | 
|      IPv6      |                                  |    IPv6      |   
|                |                                  |              |  
|SCHC Comp / Frag|                                  |              |  
+--------+-------+                                  +-------+------+ 
         |   +--+     +----+     +-----------+              .
         +~~ |RG| === |NGW | === |   SCHC    |... Internet ..
             +--+     +----+     |Comp / Frag| 
                                 +-----------+
]]></artwork></figure>

<t><xref target="Fig-archi"/> The figure represents the architecture for SCHC (Static Context Header Compression) Compression / Fragmentation 
where SCHC C/D (Compressor/Decompressor) and SCHC Fragmentation are performed. It is based on <xref target="I-D.ietf-lpwan-overview"/> 
terminology. 
SCHC Compression / Fragmentation is located on both sides of the transmission in the Dev and in the Network side.
In the Uplink direction, the Device application packets use IPv6 or IPv6/UDP protocols. Before sending these packets, the Dev 
compresses their headers using SCHC C/D and if the SCHC packet resulting from the compression exceeds the maximum payload 
size of the underlying LPWAN technology, SCHC fragmentation is performed, see <xref target="Frag"/>. The resulting SCHC fragments are sent 
as one or more L2 frames to an LPWAN Radio Gateway (RG) which forwards the frame(s) to a Network Gateway (NGW).</t>

<t>The NGW sends the data to an SCHC Fragmentation and then to the SCHC C/D for decompression. The SCHC C/D in the Network side 
can be located in the Network Gateway (NGW) or somewhere else as long as a tunnel is established between the NGW and the SCHC 
Compression / Fragmentation. Note that, for some LPWAN technologies, it may be suitable to locate fragmentation and 
reassembly functionality nearer the NGW, in order to better deal with time constraints of such technologies.
The SCHC C/Ds on both sides must share the same set of Rules. After decompression, the packet can be sent over the Internet 
to one or several LPWAN Application Servers (App).</t>

<t>The SCHC Compression / Fragmentation process is symmetrical, therefore the same description applies to the reverse direction.</t>

<section anchor="schc-cd-rules" title="SCHC C/D Rules">

<t>The main idea of the SCHC compression scheme is to transmit the Rule ID
to the other end instead of sending known field values. This Rule ID
identifies a rule that provides the closest match to the original
packet values. Hence, when a value is known by both ends, it is only
necessary to send the corresponding Rule ID over the LPWAN network. 
How Rules are generated is out of the scope of this document. The rule may be changed 
but it will be specified in another document.</t>

<t>The context contains a list of rules (cf. <xref target="Fig-ctxt"/>). Each Rule
contains itself a list of Field Descriptions composed of a field
identifier (FID), a field length (FL), a field position (FP), a
direction indicator (DI), a target value (TV), a matching operator
(MO) and a Compression/Decompression Action (CDA).</t>

<figure title="Compression/Decompression Context" anchor="Fig-ctxt"><artwork><![CDATA[
  /-----------------------------------------------------------------\
  |                         Rule N                                  |
 /-----------------------------------------------------------------\|
 |                       Rule i                                    ||
/-----------------------------------------------------------------\||
|  (FID)            Rule 1                                        |||
|+-------+--+--+--+------------+-----------------+---------------+|||
||Field 1|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act||||
|+-------+--+--+--+------------+-----------------+---------------+|||
||Field 2|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act||||
|+-------+--+--+--+------------+-----------------+---------------+|||
||...    |..|..|..|   ...      | ...             | ...           ||||
|+-------+--+--+--+------------+-----------------+---------------+||/
||Field N|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act|||
|+-------+--+--+--+------------+-----------------+---------------+|/
|                                                                 |
\-----------------------------------------------------------------/

]]></artwork></figure>

<t>The Rule does not describe how to delineate each field in the original packet header. This
must be known from the compressor/decompressor. The rule only describes the
compression/decompression behavior for each header field. In the rule, the Field Descriptions are listed in the order in 
which the fields appear in the packet header.</t>

<t>The Rule also describes the Compression Residue sent regarding the order of the Fields Descriptions in the Rule.</t>

<t>The Context describes the header fields and its values with the following entries:</t>

<t><list style="symbols">
  <t>Field ID (FID) is a unique value to define the header field.</t>
  <t>Field Length (FL) represents the length of the field in bits for fixed values or a type (variable, token length, …) for Field 
Description length unknown at the rule creation. The length of a header field is defined in the specific protocol standard.</t>
  <t>Field Position (FP): indicating if several instances of a field exist in the headers which one is targeted. The default 
position is 1.</t>
  <t>A direction indicator (DI) indicating the packet direction(s) this Field Description applies to. Three values are possible:  <list style="symbols">
      <t>UPLINK (Up): this Field Description is only applicable to packets sent by the Dev to the App,</t>
      <t>DOWNLINK (Dw): this Field Description is only applicable to packets sent from the App to the Dev,</t>
      <t>BIDIRECTIONAL (Bi): this Field Description is applicable to packets travelling both Up and Dw.</t>
    </list></t>
  <t>Target Value (TV) is the value used to make the match with the packet header field. The Target Value can be of any type 
(integer, strings, etc.). For instance, it can be a single value or a more complex structure (array, list, etc.), such as a
JSON or a CBOR structure.</t>
  <t>Matching Operator (MO) is the operator used to match the Field Value and the Target Value. The Matching Operator may 
require some parameters. MO is only used during the compression phase. The set of MOs defined in this document can be found 
in <xref target="chap-MO"/>.</t>
  <t>Compression Decompression Action (CDA) describes the compression and decompression processes to be performed after the MO <vspace />
is applied. The CDA may require some parameters to be processed. CDAs are used in both the compression and the 
decompression functions. The set of CDAs defined in this document can be found in <xref target="chap-CDA"/>.</t>
</list></t>

</section>
<section anchor="IDComp" title="Rule ID for SCHC C/D">

<t>Rule IDs are sent by the compression function in one side and are received for the decompression function in the other side. 
In SCHC C/D, the Rule IDs are specific to a Dev. Hence, multiple Dev instances may use the same Rule ID to define different 
header compression contexts. To identify the correct Rule ID, the SCHC C/D needs to correlate the Rule ID with the Dev 
identifier to find the appropriate Rule to be applied.</t>

</section>
<section anchor="packet-processing" title="Packet processing">

<t>The compression/decompression process follows several steps:</t>

<t><list style="symbols">
  <t>Compression Rule selection: The goal is to identify which Rule(s) will be used to compress the packet’s headers. When <vspace />
doing decompression, in the network side the SCHC C/D needs to find the correct Rule based on the L2 address and in this 
way, it can use the Dev-ID and the Rule-ID. In the Dev side, only the Rule ID is needed to identify the correct Rule since 
the Dev only holds Rules that apply to itself. The Rule will be selected by matching the Fields Descriptions to the packet 
header as described below. When the selection of a Rule is done, this Rule is used to compress the header. 
The detailed steps for compression Rule selection are the following:  <list style="symbols">
      <t>The first step is to choose the Fields Descriptions by their direction, using the direction indicator (DI). A Field 
Description that does not correspond to the appropriate DI will be ignored, if all the fields of the packet do not have a 
Field Description with the correct DI the Rule is discarded and SCHC C/D proceeds to explore the next Rule.</t>
      <t>When the DI has matched, then the next step is to identify the fields according to Field Position (FP). If the Field 
Position does not correspond, the Rule is not used and the SCHC C/D proceeds to consider the next Rule.</t>
      <t>Once the DI and the FP correspond to the header information, each field’s value of the packet is then compared to the 
corresponding Target Value (TV) stored in the Rule for that specific field using the matching operator (MO).</t>
      <t>If all the fields in the packet’s header satisfy all the matching operators (MO) of a Rule (i.e. all MO results are 
True), the fields of the header are then compressed according to the Compression/Decompression Actions (CDAs) and a 
compressed header (with possibly a Compressed Residue) may be obtained. Otherwise, the next Rule is tested.</t>
      <t>If no eligible Rule is found, then the header must be sent without compression, depending on the L2 PDU size, this is one 
of the case that may require the use of the fragmentation process.</t>
    </list></t>
  <t>Sending: If an eligible Rule is found, the Rule ID is sent to the other end followed by the Compression Residue (which 
could be empty) and directly followed by the payload. The product of the Compression Residue is sent in the order expressed 
in the Rule for all the fields. 
The way the Rule ID is sent depends on the specific LPWAN layer two technology. For example, it can be either included in a 
Layer 2 header or sent in the first byte of the L2 payload. (Cf. <xref target="Fig-FormatPckt"/>). This process will be specified in the 
LPWAN technology-specific document and is out of the scope of the present document. On LPWAN technologies that are byte-
oriented, the compressed header concatenated with the original packet payload is padded to a multiple of 8 bits, if needed. 
See <xref target="Padding"/> for details.</t>
  <t>Decompression: When doing decompression, in the network side the SCHC C/D needs to find the correct Rule based on the L2 
address and in this way, it can use the Dev-ID and the Rule-ID. In the Dev side, only the Rule ID is needed to identify the 
correct Rule since the Dev only holds Rules that apply to itself.  <vspace blankLines='1'/>
The receiver identifies the sender through its device-id (e.g. MAC address, if exists) and selects the appropriate Rule  <vspace />
from the Rule ID. If a source identifier is present in the L2 technology, it is used to select the Rule ID. This Rule 
describes the compressed header format and associates the values to the header fields.  The receiver applies the CDA action 
to reconstruct the original header fields. The CDA application order can be different from the order given by the Rule. For 
instance, Compute-* may be applied at the end, after all the other CDAs.</t>
</list></t>

<figure title="SCHC C/D Packet Format" anchor="Fig-FormatPckt"><artwork><![CDATA[
+--- ... --+------- ... -------+------------------+~~~~~~~
|  Rule ID |Compression Residue|  packet payload  |padding 
+--- ... --+------- ... -------+------------------+~~~~~~~
                                                   (optional)
<----- compressed header ------>

]]></artwork></figure>

</section>
<section anchor="chap-MO" title="Matching operators">

<t>Matching Operators (MOs) are functions used by both SCHC C/D endpoints involved in the header 
compression/decompression. They are not typed and can be indifferently applied to integer, string
or any other data type. The result of the operation can either be True or False. MOs are defined as follows:</t>

<t><list style="symbols">
  <t>equal: The match result is True if a field value in a packet and the value in the TV are equal.</t>
  <t>ignore: No check is done between a field value in a packet and a TV
in the Rule. The result of the matching is always true.</t>
  <t>MSB(x): A match is obtained if the most significant x bits
of the field value in the header packet are equal to the TV in the Rule. The x parameter of the MSB Matching Operator
indicates how many bits are involved in the comparison.</t>
  <t>match-mapping: With match-mapping, the Target Value is a list of values. Each value of the list is identified by a short ID (or index). Compression is achieved by sending the index instead of the original header field value.
This operator matches if the header field value is equal to one of the values in the target list.</t>
</list></t>

</section>
<section anchor="chap-CDA" title="Compression Decompression Actions (CDA)">

<t>The Compression Decompression Action (CDA) describes the actions taken during
the compression of headers fields, and inversely, the action taken by the decompressor to restore
the original value.</t>

<figure title="Compression and Decompression Functions" anchor="Fig-function"><artwork><![CDATA[
/--------------------+-------------+----------------------------\
|  Action            | Compression | Decompression              |
|                    |             |                            |
+--------------------+-------------+----------------------------+
|not-sent            |elided       |use value stored in ctxt    |
|value-sent          |send         |build from received value   |
|mapping-sent        |send index   |value from index on a table |
|LSB(y)              |send LSB     |TV, received value          |
|compute-length      |elided       |compute length              |
|compute-checksum    |elided       |compute UDP checksum        |
|Deviid              |elided       |build IID from L2 Dev addr  |
|Appiid              |elided       |build IID from L2 App addr  |
\--------------------+-------------+----------------------------/
y=size of the transmitted bits

]]></artwork></figure>

<t><xref target="Fig-function"/> summarizes the basic functions that can be used to compress and decompress
a field. The first column lists the actions name. The second and third
columns outline the reciprocal compression/decompression behavior for each action.</t>

<t>Compression is done in order that Fields Descriptions appear in the Rule. The result of each Compression/Decompression Action is appended to the working Compression Residue in that same order. The receiver knows the size of each compressed field which can be given by the rule or may be sent with the compressed header.</t>

<t>If the field is identified as being variable in the Field Description, then the size of the Compression Residue value in bytes must be sent first using the following coding:</t>

<t><list style="symbols">
  <t>If the size is between 0 and 14 bytes, it is sent as a 4-bits integer.</t>
  <t>For values between 15 and 255, the first 4 bits sent are set to 1 and the size is sent using 8 bits integer.</t>
  <t>For higher values of size, the first 12 bits are set to 1 and the next two bytes contain the size value as a 16 bits integer.</t>
  <t>If a field does not exist in the packet but in the Rule and its FL is variable, the size zero may be used.</t>
</list></t>

<section anchor="not-sent-cda" title="not-sent CDA">

<t>The not-sent function is generally used when the field value is specified in the Rule and
therefore known by both the Compressor and the Decompressor. This action is generally used with the
“equal” MO. If MO is “ignore”, there is a risk to have a decompressed field
value different from the compressed field.</t>

<t>The compressor does not send any value in the Compressed Residue for a field on which not-sent compression is applied.</t>

<t>The decompressor restores the field value with the Target Value stored in the matched Rule identified by the received Rule ID.</t>

</section>
<section anchor="value-sent-cda" title="value-sent CDA">

<t>The value-sent action is generally used when the field value is not known by both Compressor and Decompressor.
The value is sent in the compressed message header. Both Compressor and Decompressor must know the
size of the field, either implicitly (the size is known by both sides) 
or explicitly in the compression residue by indicating the length, as defined in <xref target="chap-CDA"/>. This function is generally 
used with the “ignore” MO.</t>

</section>
<section anchor="mapping-sent-cda" title="mapping-sent CDA">

<t>The mapping-sent is used to send a smaller index (the index into
the Target Value list of values) instead of the original value. This function is used together with the “match-mapping” MO.</t>

<t>On the compressor side, the match-mapping Matching Operator searches the TV for a match with the header field value and the 
mapping-sent CDA appends the corresponding index to the Compression Residue to be sent.
On the decompressor side, the CDA uses the received index to restore the field value by looking up the list in the TV.</t>

<t>The number of bits sent is the minimal size for coding all the possible indices.</t>

</section>
<section anchor="lsby-cda" title="LSB(y) CDA">

<t>The LSB(y) action is used together with the “MSB(x)” MO to avoid sending the higher part of the packet field if that part is 
already known by the receiving end. A length can be specified in the rule to indicate
how many bits have to be sent. If the length is not specified, the number of bits sent is the
original header field length minus the length specified in the MSB(x) MO.</t>

<t>The compressor sends the Least Significant Bits (e.g. LSB of the length field). The
decompressor combines the value received with the Target Value depending on the field type.</t>

<t>If this action needs to be done on a variable length field, the size of the Compressed Residue in bytes must be sent as 
described in <xref target="chap-CDA"/>.</t>

</section>
<section anchor="deviid-appiid-cda" title="DEViid, APPiid CDA">

<t>These functions are used to process respectively the Dev and the App Interface Identifiers (Deviid and Appiid) of the 
IPv6 addresses. Appiid CDA is less common since current LPWAN technologies
frames contain a single address, which is the Dev’s address.</t>

<t>The IID value MAY be computed from the Device ID present in the Layer 2 header, or from some other stable identifier. The computation is specific for each LPWAN technology and MAY depend on the Device ID size.</t>

<t>In the Downlink direction, these Deviid CDA is used to determine the L2 addresses used by the LPWAN.</t>

</section>
<section anchor="compute-" title="Compute-*">

<t>Some fields are elided during compression and reconstructed during decompression. This is the case for length and Checksum, so:</t>

<t><list style="symbols">
  <t>compute-length: computes the length assigned to this field. This CDA may be used to compute IPv6 length or UDP 
length.</t>
  <t>compute-checksum: computes a checksum from the information already received by the SCHC C/D.
This field may be used to compute UDP checksum.</t>
</list></t>

</section>
</section>
</section>
<section anchor="Frag" title="Fragmentation">

<section anchor="overview" title="Overview">

<t>In LPWAN technologies, the L2 data unit size typically varies from tens to hundreds of bytes. The SCHC fragmentation may be 
used either because after applying SCHC C/D or when SCHC C/D is not possible the entire SCHC packet still exceeds the L2 data 
unit.</t>

<t>The fragmentation functionality defined in this document has been designed under the assumption that data unit out-of-
sequence delivery will not happen between the entity performing fragmentation and the entity performing reassembly.  This 
assumption allows reducing the complexity and overhead of the fragmentation mechanism.</t>

<t>To adapt the SCHC fragmentation to the capabilities of LPWAN technologies is required to enable optional fragment 
retransmission and to allow a stepper delivery for the reliability of fragments. This document does not make any decision 
with regard to which fragment delivery reliability mode will be used over a specific LPWAN technology. These details will be 
defined in other technology-specific documents.</t>

</section>
<section anchor="fragmentation-tools" title="Fragmentation Tools">

<t>This subsection describes the different tools that are used to enable the SCHC fragmentation functionality defined in this 
document, such as fields in the SCHC fragmentation header frames (see the related formats in <xref target="Fragfor"/>), and the different 
parameters supported in the reliability modes such as timers and parameters.</t>

<t><list style="symbols">
  <t>Rule ID. The Rule ID is present in the SCHC fragment header and in the ACK header format.  The Rule ID in a SCHC fragment 
header is used to identify that a SCHC fragment is being carried, which fragmentation reliability mode is used and which 
window size is used. The Rule ID  in the fragmentation header also allows interleaving non-fragmented packets and SCHC 
fragments that carry other SCHC packets. The Rule ID in an ACK identifies the message as an ACK.</t>
  <t>Fragment Compressed Number (FCN).  The FCN is included in all SCHC fragments. This field can be understood as a truncated, 
efficient representation of a larger-sized fragment number, and does not carry an absolute fragment number. There are two 
FCN reserved values that are used for controlling the fragmentation process, as described next:
  <list style="symbols">
      <t>The FCN value with all the bits equal to 1 (All-1) denotes the last SCHC fragment of a packet. The last window of a 
packet is called an All-1 window.</t>
      <t>The FCN value with all the bits equal to 0 (All-0) denotes the last SCHC fragment of a window that is not the last one of 
the packet. Such a window is called an All-0 window.
The rest of the FCN values are assigned in a sequentially decreasing order, which has the purpose to avoid possible 
ambiguity for the receiver that might arise under certain conditions. In the SCHC fragments, this field is an unsigned 
integer, with a size of N bits. In the No-ACK mode, it is set to 1 bit (N=1), All-0 is used in all SCHC fragments and 
All-1 for the last one. 
For the other reliability modes, it is recommended to use a number of bits (N) equal to or greater than 3. Nevertheless, 
the appropriate value will be defined in the corresponding technology documents. For windows that are not the last one from 
a fragmented packet, the FCN for the last SCHC fragment in such windows is an All-0. This indicates that the window is 
finished and communication proceeds according to the reliability mode in use. The FCN for the last SCHC fragment in the 
last window is an All-1.  It is also important to note that, in the No-ACK mode or when N=1, the last fragment of the 
packet will carry a FCN equal to 1, while all previous fragments will carry a FCN of 0. For further details see 
<xref target="FragModes"/>.</t>
    </list></t>
  <t>Datagram Tag (DTag). The DTag field, if present, is set to the same value for all SCHC fragments carrying the same SCHC <vspace />
packet, and to different values for different datagrams. Using this field, the sender can interleave fragments from 
different SCHC packets, while the receiver can still tell them apart.
In the fragment formats, the size of the DTag field is T bits, which may be set to a value greater than or equal to 0 bits. 
For each new SCHC packet processed by the sender, DTag MUST be sequentially increased, from 0 to 2^T – 1 wrapping back from 
2^T - 1 to 0.
In the ACK format, DTag carries the same value as the DTag field in the fragments for which this ACK is intended.</t>
  <t>W (window): W is a 1-bit field. This field carries the same value for all SCHC fragments of a window, and it is 
complemented for the next window. The initial value for this field is 0.
In the ACK format, this field also has a size of 1 bit. In all ACKs, the W bit carries the same value as the W bit carried 
by the SCHC fragments whose reception is being positively or negatively acknowledged by the ACK.</t>
  <t>Message Integrity Check (MIC). This field, which has a size of M bits, is computed by the sender over the complete SCHC 
packet before fragmentation. The MIC allows the receiver to check errors in the reassembled packet, while it also enables 
compressing the UDP checksum by use of SCHC compression. The CRC32 as 0xEDB88320 (i.e. the reverse representation of the 
polynomial used e.g. in the Ethernet standard <xref target="RFC3385"/>) is recommended as the default algorithm for computing the MIC. 
Nevertheless, other algorithms MAY be required and are defined in the technology-specific documents.</t>
  <t>C (MIC checked): C is a 1-bit field. This field is used in the ACK packets to report the outcome of the MIC check, i.e. 
whether the reassembled packet was correctly received or not. A value of 1 represents a positive MIC check at the receiver 
side (i.e. the MIC computed by the receiver matches the received MIC).</t>
  <t>Retransmission Timer. A fragment sender uses it after the transmission of a window to detect a transmission error of 
the ACK corresponding to this window. Depending on the reliability mode, it will lead to a request an ACK 
retransmission (in ACK-Always mode) or it will trigger the transmission of the next window (in ACK-on-error mode). The 
duration of this timer is not defined in this document and must be defined in the corresponding technology documents.</t>
  <t>Inactivity Timer. A fragment receiver uses it to take action when there is a problem in the transmission of 
fragments. Such a problem could be detected by the receiver not getting a single fragment during a given period of time or 
not getting a given number of packets in a given period of time. When this happens, an Abort message will be sent (see 
related text later in this section). Initially, and each time a fragment is received, the timer is reinitialized. The 
duration of this timer is not defined in this document and must be defined in the specific technology document.</t>
  <t>Attempts. This counter counts the requests for a missing ACK. When it reaches the value MAX_ACK_REQUESTS,
the sender assume there are recurrent fragment transmission errors and determines that an Abort is needed. The default 
value offered MAX_ACK_REQUESTS is not stated in this document, and it is expected to be defined in the specific technology 
document. The Attempts counter is defined per window. It is initialized each time a new window is used.</t>
  <t>Bitmap. The Bitmap is a sequence of bits carried in an ACK. Each bit in the Bitmap corresponds to a
fragment of the current window, and provides feedback on whether the fragment has been received or not. The right-most 
position on the Bitmap reports if the All-0 or All-1 fragment has been received or not. Feedback on the
fragment with the highest FCN value is provided by the bit in the left-most position of the Bitmap. In the Bitmap, a bit 
set to 1 indicates that the fragment of FCN corresponding to that bit position has been correctly sent and received. The 
text above describes the internal representation of the Bitmap. When inserted in the ACK for transmission from the receiver 
to the sender, the Bitmap may be truncated for energy/bandwidth optimisation, see more details in <xref target="Bitmapopt"/></t>
  <t>Abort. On expiration of the Inactivity timer, or when Attempts reached MAX_ACK_REQUESTS or upon an occurrence of some other 
error, the sender or the receiver MUST use the Abort. When the receiver needs to abort the on-going fragmented 
packet transmission, it sends the Receiver-Abort format. When the sender needs to abort the transmission, it sends the 
Sender-Abort format. None of the Abort are acknowledged.</t>
  <t>Padding (P). If it is needed, the number of bits used for padding is not defined and depends on the size of the Rule ID, 
DTag and FCN fields, and on the L2 payload size (see <xref target="Padding"/>). Some ACKs are byte-aligned and do not need padding (see 
<xref target="Bitmapopt"/>).</t>
</list></t>

</section>
<section anchor="reliability-modes" title="Reliability modes">

<t>This specification defines three reliability modes: No-ACK, ACK-Always and ACK-on-Error. ACK-Always and ACK-on-Error operate on windows of fragments. A window of fragments is a subset of the full set of fragments needed to carry a packet or an SCHC packet.</t>

<t><list style="symbols">
  <t>No-ACK. No-ACK is the simplest fragment reliability mode. The receiver does not generate overhead in the form of 
acknowledgments (ACKs).  However, this mode does not enhance reliability beyond that offered by the underlying LPWAN 
technology. In the No-ACK mode, the receiver MUST NOT issue ACKs. See further details in <xref target="No-ACK-subsection"/>.</t>
  <t>ACK-Always. The ACK-Always mode provides flow control using a window scheme. This mode is also able to handle long bursts 
of lost fragments since detection of such events can be done before the end of the SCHC packet transmission as long as the 
window size is short enough. However, such benefit comes at the expense of ACK use. In ACK-Always the receiver sends an ACK 
after a window of fragments has been received, where a window of fragments is a subset of the whole number of fragments 
needed to carry a complete SCHC packet. The ACK is used to inform the sender if a fragment in the actual window has been 
lost or well received. Upon an ACK reception, the sender retransmits the lost fragments. When an ACK is lost and the sender 
has not received it before the expiration of the Inactivity Timer, the sender uses an ACK request by sending the All-1 
empty fragment. The maximum number of ACK requests is MAX_ACK_REQUESTS. If the MAX_ACK_REQUEST is reached the transmission 
needs to be Aborted. See further details in <xref target="ACK-Always-subsection"/>.</t>
  <t>ACK-on-Error. The ACK-on-Error mode is suitable for links offering relatively low L2 data unit loss probability. In this 
mode, the fragment receiver reduces the number of ACKs transmitted, which may be especially beneficial in asymmetric 
scenarios. Because the fragments use the uplink of the underlying LPWAN technology, which has higher capacity than 
downlink. The receiver transmits an ACK only after the complete window transmission and if at least one fragment of this 
window has been lost. An exception to this behavior is in the last window, where the receiver MUST transmit an ACK, 
including the C bit set based on the MIC checked result, even if all the fragments of the last window have been correctly 
received.
The ACK gives the state of all the fragments (received or lost). Upon an ACK reception, the sender retransmits the lost 
fragments. If an ACK is not transmitted back by the receiver at the end of a window, the sender assumes that all fragments 
have been correctly received.
When the ACK is lost, the sender assumes that all fragments covered by the lost ACK have been successfully delivered, so 
the sender continues transmitting the next window of fragments. If the next fragments received belong to the next window, 
the receiver will discard this fragments and the receiver will abort the on-going fragmented packet transmission. 
See further details in <xref target="ACK-on-Error-subsection"/>.</t>
</list></t>

<t>The same reliability mode must be used for all fragments of an SCHC packet. The decision on which reliability mode will be 
used and whether the same reliability mode applies to all SCHC packets is an implementation problem and is out of the scope 
of this document.</t>

<t>Note that the reliability mode choice is not necessarily tied to a particular characteristic of the underlying L2 LPWAN 
technology, e.g. the No-ACK mode may be used on top of an L2 LPWAN technology with symmetric characteristics for uplink and 
downlink. This document does not make any decision as to which fragment reliability mode(s) are supported by a specific LPWAN 
technology.</t>

<t>Examples of the different reliability modes described are provided in Appendix B.</t>

</section>
<section anchor="Fragfor" title="Fragmentation Formats">

<t>This section defines the fragment format, the All-0 and All-1 formats, the ACK format and the Abort formats.</t>

<section anchor="fragment-format" title="Fragment format">

<t>A fragment comprises a fragment header, a fragment payload and padding bits (if needed). A fragment conforms to the general 
format shown in <xref target="Fig-FragFormat"/>. The fragment payload carries a subset of SCHC packet. 
A fragment is the payload of the L2 protocol data unit (PDU). Padding MAY be added in fragments and in ACKs if necessary, 
therefore a padding field is optional (this is explicitly indicated in <xref target="Fig-FragFormat"/> for the sake of illustration 
clarity.</t>

<figure title="Fragment general format. Presence of a padding field is optional" anchor="Fig-FragFormat"><artwork><![CDATA[
      +-----------------+-----------------------+~~~~~~~~~~~~~~~
      | Fragment Header |   Fragment payload    | padding (opt.) 
      +-----------------+-----------------------+~~~~~~~~~~~~~~~
]]></artwork></figure>

<t>In ACK-Always or ACK-on-Error, fragments except the last one SHALL conform the detailed format defined in <xref target="Fig-NotLastWin"/>. 
The total size of the fragment header is R bits. Where is R is not a multiple of 8 bits.</t>

<figure title="Fragment Detailed Format for Fragments except the Last One, Window mode" anchor="Fig-NotLastWin"><artwork><![CDATA[
 <------------ R ----------->
            <--T--> 1 <--N-->
 +-- ... --+- ... -+-+- ... -+--------...-------+
 | Rule ID | DTag  |W|  FCN  | Fragment payload | 
 +-- ... --+- ... -+-+- ... -+--------...-------+

]]></artwork></figure>

<t>In the No-ACK mode, fragments except the last one SHALL conform to the detailed format defined in <xref target="Fig-NotLast"/>. The total 
size of the fragment header is R bits.</t>

<figure title="Fragment Detailed Format for Fragments except the Last One, No-ACK mode" anchor="Fig-NotLast"><artwork><![CDATA[
<------------ R ----------->
             <--T--> <--N-->
 +-- ... --+- ...  -+- ... -+--------...-------+
 | Rule ID |  DTag  |  FCN  | Fragment payload | 
 +-- ... --+- ...  -+- ... -+--------...-------+
             

]]></artwork></figure>

<t>In all these cases, R may not be a multiple of 8 bits.</t>

</section>
<section anchor="all-1-and-all-0-formats" title="All-1 and All-0 formats">

<t>The All-0 format is used for sending the last fragment of a window that is not the last window of the packet.</t>

<figure title="All-0 fragment detailed format" anchor="Fig-All0"><artwork><![CDATA[
     <------------ R ----------->
                <- T -> 1 <- N -> 
     +-- ... --+- ... -+-+- ... -+--- ... ---+
     | Rule ID | DTag  |W|  0..0 |  payload  |  
     +-- ... --+- ... -+-+- ... -+--- ... ---+
     
]]></artwork></figure>

<t>The All-0 empty fragment format is used by a sender to request the retransmission of an ACK by the receiver. It is only used in ACK-Always mode.</t>

<figure title="All-0 empty fragment detailed format" anchor="Fig-All0empty"><artwork><![CDATA[
 <------------ R ----------->
            <- T -> 1 <- N -> 
 +-- ... --+- ... -+-+- ... -+
 | Rule ID | DTag  |W|  0..0 | (no payload)  
 +-- ... --+- ... -+-+- ... -+
              
]]></artwork></figure>

<t>In the No-ACK mode, the last fragment of an IPv6 datagram SHALL contain a fragment header that conforms to 
the detaield format shown in <xref target="Fig-Last"/>. The total size of this fragment header is R+M bits.</t>

<figure title="All-1 Fragment Detailed Format for the Last Fragment, No-ACK mode" anchor="Fig-Last"><artwork><![CDATA[
<------------ R ----------->
              <- T -> <N=1> <---- M ---->
+---- ... ---+- ... -+-----+---- ... ----+---...---+
|   Rule ID  | DTag  |  1  |     MIC     | payload |
+---- ... ---+- ... -+-----+---- ... ----+---...---+
    
]]></artwork></figure>

<t>In any of the Window modes, the last fragment of an IPv6 datagram SHALL contain a fragment header that conforms to 
   the detailed format shown in <xref target="Fig-LastWinMode"/>. The total size of the fragment
   header in this format is R+M bits.</t>

<figure title="All-1 Fragment Detailed Format for the Last Fragment, ACK-Always or ACK-on-Error" anchor="Fig-LastWinMode"><artwork><![CDATA[
<------------ R ----------->
           <- T -> 1 <- N -> <---- M ---->
+-- ... --+- ... -+-+- ... -+---- ... ----+---...---+
| Rule ID | DTag  |W| 11..1 |     MIC     | payload |
+-- ... --+- ... -+-+- ... -+---- ... ----+---...---+
                      (FCN)
]]></artwork></figure>

<t>In either ACK-Always or ACK-on-Error, in order to request a retransmission of the ACK for the All-1 window, the fragment sender uses the format shown in <xref target="Fig-All1retries"/>. The total size of the fragment header in this format is R+M bits.</t>

<figure title="All-1 for Retries format, also called All-1 empty" anchor="Fig-All1retries"><artwork><![CDATA[
<------------ R ----------->
           <- T -> 1 <- N -> <---- M ---->
+-- ... --+- ... -+-+- ... -+---- ... ----+
| Rule ID | DTag  |W|  1..1 |     MIC     | (no payload)  
+-- ... --+- ... -+-+- ... -+---- ... ----+

]]></artwork></figure>

<t>The values for R, N, T and M are not specified in this document, and SHOULD be determined in other documents (e.g. technology-specific profile documents).</t>

</section>
<section anchor="ack-format" title="ACK format">

<t>The format of an ACK that acknowledges a window that is not the last one (denoted as All-0 window) is shown in <xref target="Fig-ACK-Format"/>.</t>

<figure title="ACK format for All-0 windows" anchor="Fig-ACK-Format"><artwork><![CDATA[
  <--------- R -------->
              <- T -> 1  
  +---- ... --+-... -+-+---- ... -----+
  |  Rule ID  | DTag |W|encoded Bitmap| (no payload)
  +---- ... --+-... -+-+---- ... -----+
                
]]></artwork></figure>

<t>To acknowledge the last window of a packet (denoted as All-1 window), a C bit (i.e. MIC checked) following the W bit is set
to 1 to indicate that the MIC check computed by the receiver matches the MIC present in the All-1 fragment. If the MIC check fails, the C bit is set to 0 and the Bitmap for the All-1 window follows.</t>

<figure title="Format of an ACK for All-1 windows" anchor="Fig-ACK-Format1"><artwork><![CDATA[
<---------- R --------->
            <- T -> 1 1
+---- ... --+-... -+-+-+
|  Rule ID  | DTag |W|1| (MIC correct)
+---- ... --+-... -+-+-+
                                       
+---- ... --+-... -+-+-+----- ... -----+
|  Rule ID  | DTag |W|0|encoded Bitmap |(MIC Incorrect)
+---- ... --+-... -+-+-+----- ... -----+
                      C
                
]]></artwork></figure>

<section anchor="Bitmapopt" title="Bitmap Encoding">

<t>The Bitmap is transmitted by a receiver as part of the ACK format. An ACK message may include padding at the end to align its 
number of transmitted bits to a multiple of 8 bits.</t>

<t>Note that the ACK sent in response to an All-1 fragment includes the C bit. Therefore, the window size and thus the encoded 
Bitmap size need to be determined taking into account the available space in the layer two frame payload, where there will be 
1 bit less for an ACK sent in response to an All-1 fragment than in other ACKs. Note that the maximum number of fragments of the last window is one unit smaller than that of the previous windows.</t>

<t>When the receiver transmits an encoded Bitmap with a fragment that has not been sent during the transmission, the sender will 
Abort the transmission.</t>

<figure title="A non-encoded Bitmap" anchor="Fig-Localbitmap"><artwork><![CDATA[
                    <----         Bitmap bits      ---->   
| Rule ID | DTag |W|1|0|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|   
|--- byte boundary ----| 1 byte  next  |  1 byte next  |   
      
]]></artwork></figure>

<t>In order to reduce the resulting frame size, the encoded Bitmap is shortened by applying the following algorithm: all the 
right-most contiguous bytes in the encoded Bitmap that have all their bits set to 1 MUST NOT be transmitted.  Because the fragment sender knows the actual Bitmap size, it can reconstruct the original Bitmap with the trailing 1 bit optimized away.  In the example shown in <xref target="Fig-transmittedbitmap"/>, the last 2 bytes of the Bitmap shown in <xref target="Fig-Localbitmap"/> comprise bits that are all set to 1, therefore they are not sent.</t>

<figure title="Optimized Bitmap format" anchor="Fig-transmittedbitmap"><artwork><![CDATA[
     <-------   R  ------->  
                 <- T -> 1 
     +---- ... --+-... -+-+-+-+
     |  Rule ID  | DTag |W|1|0|
     +---- ... --+-... -+-+-+-+
     |---- byte boundary -----|    
     
]]></artwork></figure>

<t><xref target="Fig-Bitmap-Win"/> shows an example of an ACK with FCN ranging from 6 down to 0, where the Bitmap
indicates that the second and the fifth fragments have not been correctly received.</t>

<figure title="Example of a Bitmap before transmission, and the transmitted one, in any window except the last one" anchor="Fig-Bitmap-Win"><artwork><![CDATA[
<------   R  ------>6 5 4 3 2 1   0 (*) 
          <- T -> 1   
+---------+------+-+-+-+-+-+-+-+-----+
| Rule ID | DTag |W|1|0|1|1|0|1|all-0| Bitmap(before tx)
+---------+------+-+-+-+-+-+-+-+-----+
|<-- byte boundary ->|<---- 1 byte---->| 
    (*)=(FCN values) 
    
+---------+------+-+-+-+-+-+-+-+-----+~~
| Rule ID | DTag |W|1|0|1|1|0|1|all-0|Padding(opt.) encoded Bitmap
+---------+------+-+-+-+-+-+-+-+-----+~~
|<-- byte boundary ->|<---- 1 byte---->| 
    
]]></artwork></figure>

<t><xref target="Fig-Bitmap-lastWin"/> shows an example of an ACK with FCN ranging from 6 down to 0, where the Bitmap indicates that the MIC check has failed but there are no missing fragments.</t>

<figure title="Example of the Bitmap in ACK-always or ACK-on-error for the last window, for N=3)" anchor="Fig-Bitmap-lastWin"><artwork><![CDATA[
 <-------   R  ------->  6 5 4 3 2 1 7 (*) 
             <- T -> 1 1
 |  Rule ID  | DTag |W|0|1|1|1|1|1|1|1|padding|  Bitmap (before tx)
 |---- byte boundary -----|  1 byte next |  
                       C
 +---- ... --+-... -+-+-+-+
 |  Rule ID  | DTag |W|0|1| encoded Bitmap
 +---- ... --+-... -+-+-+-+
 |<--- byte boundary ---->| 
   (*) = (FCN values indicating the order)
   
]]></artwork></figure>

</section>
</section>
<section anchor="abort-formats" title="Abort formats">

<t>Abort are coded as exceptions to the previous coding, a specific format is defined for each direction. When a fragment sender 
needs to abort the transmission, it sends the Sender-Abort format <xref target="Fig-All1Abort"/>, that is an All-1 fragment with no MIC or 
payload. In regular cases All-1 fragment contains at least a MIC value. This absence of the MIC value indicates an Abort.</t>

<t>When a fragment receiver needs to abort the on-going fragmented packet transmission, it transmits the Receiver-Abort format 
<xref target="Fig-ACKabort"/>, creating an exception in the encoded Bitmap coding. Encoded Bitmap avoid sending the rigth most bits of the 
Bitmap set to 1. Abort is coded as an ACK message with a Bitmap set to 1 until the byte boundary, followed by an extra 0xFF 
byte. Such message never occurs in a regular acknowledgement and is view as an abort.</t>

<t>None of these messages are acknowledgement nor retransmitted.</t>

<t>The sender uses the Sender-Abort when the MAX_ACK_REQUEST is reached. The receiver uses the Receiver-Abort when the 
Inactivity timer expires, or in the ACK-on-Error mode, ACK is lost and the sender transmits fragments of a new window. Some 
other cases for Abort are explained in the <xref target="FragModes"/> or <xref target="FSM"/>.</t>

<figure title="Sender-Abort format. All FCN fields in this format are set to 1" anchor="Fig-All1Abort"><artwork><![CDATA[
<------------- R -----------><--- 1 byte --->
+--- ... ---+- ... -+-+-...-+-+-+-+-+-+-+-+-+
|  Rule ID  | DTag  |W| FCN |       FF      | (no MIC & no payload)  
+--- ... ---+- ... -+-+-...-+-+-+-+-+-+-+-+-+
   
]]></artwork></figure>

<figure title="Receiver-Abort format" anchor="Fig-ACKabort"><artwork><![CDATA[
 <----- byte boundary ------><--- 1 byte --->

 +---- ... --+-... -+-+-+-+-+-+-+-+-+-+-+-+-+
 |  Rule ID  | DTag |W| 1..1|       FF      |  
 +---- ... --+-... -+-+-+-+-+-+-+-+-+-+-+-+-+
 
]]></artwork></figure>

</section>
</section>
<section anchor="FragModes" title="Baseline mechanism">

<t>If after applying SCHC header compression (or when SCHC header compression is not possible) the SCHC packet does not fit 
within the payload of a single L2 data unit, the SCHC packet SHALL be broken into fragments and the fragments SHALL be sent 
to the fragment receiver.
The fragment receiver needs to identify all the fragments that belong to a given SCHC packet. To this end, the receiver 
SHALL use:</t>

<t><list style="symbols">
  <t>The sender’s L2 source address (if present),</t>
  <t>The destination’s L2 address (if present),</t>
  <t>Rule ID,</t>
  <t>DTag (if present).</t>
</list></t>

<t>Then, the fragment receiver may determine the fragment reliability mode that is used for this fragment based on the Rule ID 
in that fragment.</t>

<t>After a fragment reception, the receiver starts constructing the SCHC packet. It uses the FCN and the arrival order of each 
fragment to determine the location of the individual fragments within the SCHC packet. For example, the receiver may place 
the fragment payload within a payload datagram reassembly buffer at the location determined from the FCN, the arrival order 
of the fragments, and the fragment payload sizes. In Window mode, the fragment receiver also uses the W bit in the received 
fragments. Note that the size of the original, unfragmented packet cannot be determined from fragmentation headers.</t>

<t>Fragmentation functionality uses the FCN value to transmit the fragments. It has a length of N bits where the All-1 and All-0 
FCN values are used to control the fragmentation transmission. The rest of the FCN numbers MUST be assigned sequentially in a 
decreasing order, the first FCN of a window is RECOMMENDED to be 2^N-2, i.e. the highest possible FCN value depending on the 
FCN number of bits.</t>

<t>In all modes, the last fragment of a packet must contain a MIC which is used to check if there are errors or missing 
fragments and must use the corresponding All-1 fragment format.  Note that a fragment with an All-0 format is considered the 
last fragment of the current window.</t>

<t>If the receiver receives the last fragment of a datagram (All-1), it checks for the integrity of the reassembled datagram, 
based on the MIC received. In No-ACK, if the integrity check indicates that the reassembled datagram does not match the 
original datagram (prior to fragmentation), the reassembled datagram MUST be discarded. In Window mode, a MIC check is also 
performed by the fragment receiver after reception of each subsequent fragment retransmitted after the first MIC check.</t>

<t>There are three reliability modes: No-ACK, ACK-Always and ACK-on-Error. In ACK-Always and ACK-on-Error, a jumping window 
protocol uses two windows alternatively, identified as 0 and 1.  A fragment with all FCN bits set to 0 (i.e. an All-0 
fragment) indicates that the window is over (i.e. the fragment is the last one of the window) and allows to switch from one 
window to the next one.  The All-1 FCN in a fragment indicates that it is the last fragment of the packet being transmitted 
and therefore there will not be another window for this packet.</t>

<section anchor="No-ACK-subsection" title="No-ACK">
<t>In the No-ACK mode, there is no feedback communication from the fragment receiver. The sender will send all the fragments of 
a packet without any possibility of knowing if errors or losses have occurred. As, in this mode, there is no need to identify 
specific fragments, a one-bit FCN may be used. Consequently, the FCN All-0 value is used in all fragments except the last 
one, which carries an All-1 FCN and the MIC.
The receiver will wait for fragments and will set the Inactivity timer. The receiver will use the MIC contained in the last 
fragment to check for errors.
When the Inactivity Timer expires or if the MIC check indicates that the reassembled packet does not match the original one, 
the receiver will release all resources allocated to reassembling this packet. The initial value of the Inactivity Timer will 
be determined based on the characteristics of the underlying LPWAN technology and will be defined in other documents (e.g. 
technology-specific profile documents).</t>

</section>
<section anchor="ACK-Always-subsection" title="ACK-Always">
<t>In ACK-Always, the sender transmits fragments by using the two-jumping-windows procedure. A delay between each fragment can 
be added to respect local regulations or other constraints imposed by the applications.  Each time a fragment is sent, the 
FCN is decreased by one.  When the FCN reaches value 0 and there are more fragments to be sent after, the sender transmits 
the last fragment of this window using the All-0 fragment format, it starts the Retransmission Timer and waits for an ACK. On 
the other hand, if the FCN has reached 0 and this fragment to be transmitted is the last fragment of the SCHC packet, the 
sender uses the All-1 fragment format, which includes a MIC. The sender sets the Retransmission Timer and waits for the ACK 
to know if transmission errors have occured.</t>

<t>The Retransmission Timer is dimensioned based on the LPWAN technology in use. When the Retransmission Timer expires, the 
sender sends an All-0 empty (resp. All-1 empty) fragment to request again the ACK for the window that ended with the All-0 
(resp. All-1) fragment just sent. The window number is not changed.</t>

<t>After receiving an All-0 or All-1 fragment, the receiver sends an ACK with an encoded Bitmap reporting whether any fragments 
have been lost or not. When the sender receives an ACK, it checks the W bit carried by the ACK. Any ACK carrying an 
unexpected W bit value is discarded. If the W bit value of the received ACK is correct, the sender analyzes the rest of the 
ACK message, such as the encoded Bitmap and the MIC.  If all the fragments sent for this window have been well received, and 
if at least one more fragment needs to be sent, the sender advances its sending window to the next window value and sends the 
next fragments.  If no more fragments have to be sent, then the fragmented packet transmission is finished.</t>

<t>However, if one or more fragments have not been received as per the ACK (i.e. the corresponding bits are not set in the 
encoded Bitmap) then the sender resends the missing fragments.  When all missing fragments have been retransmitted, the 
sender starts the Retransmission Timer, even if an All-0 or an All-1 has not been sent as part of this retransmission and 
waits for an ACK. Upon receipt of the ACK, if one or more fragments have not yet been received, the counter Attempts is 
increased and the sender resends the missing fragments again. When Attempts reaches MAX_ACK_REQUESTS, the sender aborts the 
on-going fragmented packet transmission by sending an Abort message and releases any resources for transmission of the 
packet. The sender also aborts an on-going fragmented packet transmission when a failed MIC check is reported by the receiver 
or when a fragment that has not been sent is reported in the encoded Bitmap.</t>

<t>On the other hand, at the beginning, the receiver side expects to receive window 0.  Any fragment received but not belonging 
to the current window is discarded.  All fragments belonging to the correct window are accepted, and the actual fragment 
number managed by the receiver is computed based on the FCN value.  The receiver prepares the encoded Bitmap to report the 
correctly received and the missing fragments for the current window. After each fragment is received the receiver initializes 
the Inactivity timer, if the Inactivity Timer expires the transmission is aborted.</t>

<t>When an All-0 fragment is received, it indicates that all the fragments have been sent in the current window.  Since the 
sender is not obliged to always send a full window, some fragment number not set in the receiver memory may not correspond 
to losses.  The receiver sends the corresponding ACK, the Inactivity Timer is set and the transmission of the next window 
by the sender can start.</t>

<t>If an All-0 fragment has been received and all fragments of the current window have also been received, the receiver then 
expects a new Window and waits for the next fragment.  Upon receipt of a fragment, if the window value has not changed, the 
received fragments are part of a retransmission. A receiver that has already received a fragment should discard it, 
otherwise, it updates the encoded Bitmap.  If all the bits of the encoded Bitmap are set to one, the receiver may send an ACK 
without waiting for an All-0 fragment and the Inactivity Timer is initialized.</t>

<t>On the other hand, if the window value of the next received fragment is set to the next expected window value, this means 
that the sender has received a correct encoded Bitmap reporting that all fragments have been received.  The receiver then 
updates the value of the next expected window.</t>

<t>When an All-1 fragment is received, it indicates that the last fragment of the packet has been sent.  Since the last window 
is not always full, the MIC will be used to detect if all fragments of the packet have been received.  A correct MIC 
indicates the end of the transmission but the receiver must stay alive for an Inactivity Timer period to answer to any 
empty All-1 fragments the sender may send if ACKs sent by the receiver are lost. If the MIC is incorrect, some fragments 
have been lost.  The receiver sends the ACK regardless of successful fragmented packet reception or not, the Inactitivity 
Timer is set.  In case of an incorrect MIC, the receiver waits for fragments belonging to the same window. After 
MAX_ACK_REQUESTS, the receiver will abort the on-going fragmented packet transmission by transmitting a data unit with the 
Receiver-Abort format.  The receiver also aborts upon Inactivity Timer expiration.</t>

</section>
<section anchor="ACK-on-Error-subsection" title="ACK-on-Error">
<t>The ACK-on-Error sender is similar to ACK-Always, the main difference being that in ACK-on-Error the ACK with the encoded Bitmap is not sent at the end of each window but only when at least one fragment of the current window has been lost (with the exception of the last window).  In Ack-on-Error, the Retransmission Timer expiration will be considered as a positive acknowledgment. The Retransmission Timer is set when sending an All-0 or an All-1 fragment. When the All-1 fragment has been sent, then the on-going fragmented packet transmission fragmentation is finished and the sender waits for the last ACK. At the receiver side, when the All-1 fragment is received and the MIC check indicates successful packet reception, an ACK is sent anyway, to confirm the end of a correct transmission.  If the Retransmission Timer expires while waiting for the ACK for the last window, an All-1 empty request for the last ACK MUST be sent by the sender to complete the fragmented packet transmission.</t>

<t>If the sender receives an ACK, it checks the window value.  ACKs with an unexpected window number are discarded.  If the 
window number on the received encoded Bitmap is correct, the sender verifies if the receiver has received all fragments of the current window.  When at least one fragment has been lost, the counter Attempts is increased by one and the sender resends the missing fragments again.  When Attempts reaches MAX_ACK_REQUESTS, the sender sends an Abort message and releases all resources for the on-going fragmented packet transmission.  When the retransmission of the missing fragments is finished, the sender starts listening for an ACK (even if an All-0 or an All-1 has not been sent during the retransmission) and 
initializes the Retransmission Timer. After sending an All-1 fragment, the sender listens for an ACK, 
initializes Attempts, and starts the Retransmission Timer. If the Retransmission Timer expires, Attempts 
is increased by one and an empty All-1 fragment is sent to request the ACK for the last window. If Attempts reaches 
MAX_ACK_REQUESTS, the sender aborts the on-going fragmented packet transmission by transmitting the Sender-Abort data unit.</t>

<t>Unlike the sender, the receiver for ACK-on-Error has a larger amount of differences compared with ACK-Always.  First, an 
ACK is not sent unless there is a lost fragment or an unexpected behavior (with the exception of the last window, where an 
ACK is always sent regardless of fragment losses or not).  The receiver starts by expecting fragments from window 0 and 
maintains the information regarding which fragments it receives.  After receiving a fragment, the Inactivity Timer is set. 
If no further fragment is received and the Inactivity Timer expires, the fragment receiver aborts the on-going fragmented packet transmission by transmitting the Receiver-Abort data unit.</t>

<t>Any fragment not belonging to the current window is discarded. The actual fragment number is computed based on the FCN 
value.  When an All-0 fragment is received and all fragments have been received, the receiver updates the expected window 
value and expects a new window and waits for the next fragment.<vspace />
If the window value of the next fragment has not changed, the received fragment is a retransmission.  A receiver that has 
already received a fragment should discard it.  If all fragments of a window (that is not the last one) have been received, 
the receiver does not send an ACK.  While the receiver waits for the next window and if the window value is set to the next 
value, and if an All-1 fragment with the next value window arrived the receiver aborts the on-going fragmented packet 
transmission, and it drops the fragments of the aborted packet transmission.</t>

<t>If the receiver receives an All-1 fragment, this means that the transmission should be finished.  If the MIC is incorrect 
some fragments have been lost.  Regardless of fragment losses, the receiver sends an ACK and initializes the Inactivity 
Timer.</t>

<t>Reception of an All-1 fragment indicates the last fragment of the packet has been sent.  Since the last window is not 
always full, the MIC will be used to detect if all fragments of the window have been received.  A correct MIC check 
indicates the end of the fragmented packet transmission. An ACK is sent by the fragment receiver. In case of an incorrect 
MIC, the receiver waits for fragments belonging to the same window or the expiration of the Inactivity Timer. The latter 
will lead the receiver to abort the on-going fragmented packet transmission.</t>

</section>
</section>
<section anchor="supporting-multiple-window-sizes" title="Supporting multiple window sizes">

<t>For ACK-Always or ACK-on-Error, implementers may opt to support a single window size or multiple window sizes.  The latter, when feasible, may provide performance optimizations.  For example, a large window size may be used for packets that need to be carried by a large number of fragments.  However, when the number of fragments required to carry a packet is low, a smaller window size, and thus a shorter Bitmap, may be sufficient to provide feedback on all fragments.  If multiple window sizes are supported, the Rule ID may be used to signal the window size in use for a specific packet transmission.</t>

<t>Note that the same window size MUST be used for the transmission of all fragments that belong to the same SCHC packet.</t>

</section>
<section anchor="downlink-fragment-transmission" title="Downlink fragment transmission">

<t>In some LPWAN technologies, as part of energy-saving techniques, downlink transmission is only possible immediately after an 
uplink transmission. In order to avoid potentially high delay in the downlink transmission of a fragmented datagram, the 
fragment receiver MAY perform an uplink transmission as soon as possible after reception of a fragment that is not the last 
one. Such uplink transmission may be triggered by the L2 (e.g. an L2 ACK sent in response to a fragment encapsulated in a L2 
frame that requires an L2 ACK) or it may be triggered from an upper layer.</t>

<t>For downlink transmission of a fragmented packet in ACK-Always mode, the fragment receiver MAY support timer-based ACK
retransmission. In this mechanism, the fragment receiver initializes and starts a timer (the Inactivity Timer is used) after 
the transmission of an ACK, except when the ACK is sent in response to the last fragment of a packet (All-1 fragment). In the 
latter case, the fragment receiver does not start a timer after transmission of the ACK.</t>

<t>If, after transmission of an ACK that is not an All-1 fragment, and before expiration of the corresponding Inactivity timer, 
the fragment receiver receives a fragment that belongs to the current window (e.g. a missing fragment from the current 
window) or to the next window, the Inactivity timer for the ACK is stopped. However, if the Inactivity timer expires, the ACK 
is resent and the Inactivity timer is reinitialized and restarted.</t>

<t>The default initial value for the Inactivity timer, as well as the maximum number of retries for a specific ACK, denoted 
MAX_ACK_RETRIES, are not defined in this document, and need to be defined in other documents (e.g. technology-specific 
profiles). The initial value of the Inactivity timer is expected to be greater than that of the Retransmission timer, in 
order to make sure that a (buffered) fragment to be retransmitted can find an opportunity for that transmission.</t>

<t>When the fragment sender transmits the All-1 fragment, it starts its Retransmission Timer with a large timeout value (e.g. 
several times that of the initial Inactivity timer). If an ACK is received before expiration of this timer, the fragment 
sender retransmits any lost fragments reported by the ACK, or if the ACK confirms successful reception of all fragments of 
the last window, the transmission of the fragmented packet is considered complete. If the timer expires, and no ACK has been 
received since the start of the timer, the fragment sender assumes that the All-1 fragment has been successfully received 
(and possibly, the last ACK has been lost: this mechanism assumes that the retransmission timer for the All-1 fragment is 
long enough to allow several ACK retries if the All-1 fragment has not been received by the fragment receiver, and it also 
assumes that it is unlikely that several ACKs become all lost).</t>

</section>
</section>
<section anchor="Padding" title="Padding management">

<t>The headers specified in this document, be there for compression, fragmentation or acknowledgment, are not necessarily an 
integer number of bytes in size. Some LPWAN technologies have PDUs that are integer numbers of bytes. With such a technology, 
the sender can append padding bits to the messages defined in this document in order to fill up the last byte of the L2 PDU, 
if it isn’t already full.
Examples are shown in <xref target="Fig-FormatPckt"/> and <xref target="Fig-FragFormat"/>.</t>

<t>The receiver will tell the header, the payload and the padding apart using the following principles:
 * The size of any SCHC header is known from examining the Rule ID and the content of that header.</t>

<t><list style="symbols">
  <t>The payload that follows the header, if it exists, is variable in size, but is always a integer number of bytes.</t>
  <t>Padding MUST not add more than 7 bits.</t>
</list></t>

<t>Therefore, the algorithm for padding elimination at the receiver is the following:</t>

<t><list style="symbols">
  <t>decode the SCHC header, find its length (in bits) and set a pointer to the end of the header.</t>
  <t>from that pointer, extract as many blocks of 8 bits as are available in the L2 PDU. They are the payload bytes.</t>
  <t>the remaining bits, if any, are padding.</t>
</list></t>

</section>
<section anchor="schc-compression-for-ipv6-and-udp-headers" title="SCHC Compression for IPv6 and UDP headers">

<t>This section lists the different IPv6 and UDP header fields and how they can be compressed.</t>

<section anchor="ipv6-version-field" title="IPv6 version field">

<t>This field always holds the same value. Therefore, in the rule, TV is set to 6, MO to “equal”
and CDA to “not-sent”.</t>

</section>
<section anchor="ipv6-traffic-class-field" title="IPv6 Traffic class field">

<t>If the DiffServ field does not vary and is known by both sides, the Field Descriptor in the rule should contain a TV with 
this well-known value, an “equal” MO and a “not-sent” CDA.</t>

<t>Otherwise, two possibilities can be considered depending on the variability of the value:</t>

<t><list style="symbols">
  <t>One possibility is to not compress the field and send the original value. In the rule, TV is not set to any particular value, MO is set to “ignore” and CDA is set to “value-sent”.</t>
  <t>If some upper bits in the field are constant and known, a better option is to only send the LSBs. In the rule, TV is set to a value with the stable known upper part, MO is set to MSB(x) and CDA to LSB(y).</t>
</list></t>

</section>
<section anchor="flow-label-field" title="Flow label field">

<t>If the Flow Label field does not vary and is known by both sides, the Field Descriptor in the rule should contain a TV with 
this well-known value, an “equal” MO and a “not-sent” CDA.</t>

<t>Otherwise, two possibilities can be considered:</t>

<t><list style="symbols">
  <t>One possibility is to not compress the field and send the original value. In the rule, TV is not set to any particular value, MO is set to “ignore” and CDA is set to “value-sent”.</t>
  <t>If some upper bits in the field are constant and known, a better option is to only send the LSBs. In the rule, TV is set to a value with the stable known upper part, MO is set to MSB(x) and CDA to LSB(y).</t>
</list></t>

</section>
<section anchor="payload-length-field" title="Payload Length field">

<t>This field can be elided for the transmission on the LPWAN network. The SCHC C/D recomputes the original payload length
value. In the Field Descriptor, TV is not set, MO is set to “ignore” and CDA is “compute-IPv6-length”.</t>

<t>If the payload length needs to be sent and does not need to be coded in 16 bits, the TV can be set to 0x0000, the MO set to MSB(16-s) where ‘s’ is the number of bits to code the maximum length, and CDA is set to LSB(s).</t>

</section>
<section anchor="next-header-field" title="Next Header field">

<t>If the Next Header field does not vary and is known by both sides, the Field Descriptor in the rule should contain a TV with 
this Next Header value, the MO should be “equal” and the CDA should be “not-sent”.</t>

<t>Otherwise, TV is not set in the Field Descriptor, MO is set to “ignore” and CDA is set to
“value-sent”. Alternatively, a matching-list may also be used.</t>

</section>
<section anchor="hop-limit-field" title="Hop Limit field">

<t>The field behavior for this field is different for Uplink and Downlink. In Uplink, since there is
no IP forwarding between the Dev and the SCHC C/D, the value is relatively constant. On the
other hand, the Downlink value depends of Internet routing and may change more frequently.
One neat way of processing this field is to use the Direction Indicator (DI) to distinguish both directions:</t>

<t><list style="symbols">
  <t>in the Uplink, elide the field: the TV in the Field Descriptor is set to the known constant value, the MO
is set to “equal” and the CDA is set to “not-sent”.</t>
  <t>in the Downlink, send the value: TV is not set, MO is set to “ignore” and
CDA is set to “value-sent”.</t>
</list></t>

</section>
<section anchor="ipv6-addresses-fields" title="IPv6 addresses fields">

<t>As in 6LoWPAN <xref target="RFC4944"/>, IPv6 addresses are split into two 64-bit long fields;
one for the prefix and one for the Interface Identifier (IID). These fields should
be compressed. To allow for a single rule being used for both directions, these values are identified by their role
(DEV or APP) and not by their position in the frame (source or destination).</t>

<section anchor="ipv6-source-and-destination-prefixes" title="IPv6 source and destination prefixes">

<t>Both ends must be synchronized with the appropriate prefixes. For a specific flow, 
the source and destination prefixes can be unique and stored in the context. It can 
be either a link-local prefix or a global prefix. In that case, the TV for the 
source and destination prefixes contain the values, the MO is set to “equal” and
the CDA is set to “not-sent”.</t>

<t>If the rule is intended to compress packets with different prefix values, match-mapping should be used. The
different prefixes are listed in the TV, the MO is set to “match-mapping” and the CDA is set to “mapping-sent”. See <xref target="Fig-fields"/></t>

<t>Otherwise, the TV contains the prefix, the MO is set to “equal” and the CDA is set to
“value-sent”.</t>

</section>
<section anchor="ipv6-source-and-destination-iid" title="IPv6 source and destination IID">

<t>If the DEV or APP IID are based on an LPWAN address, then the IID can be reconstructed 
with information coming from the LPWAN header. In that case, the TV is not set, the MO 
is set to “ignore” and the CDA is set to “DEViid” or “APPiid”. Note that the 
LPWAN technology generally carries a single identifier corresponding to the DEV. Therefore Appiid cannot be used.</t>

<t>For privacy reasons or if the DEV address is changing over time, a static value that is not equal to the DEV address SHOULD 
be used.  In that case, the TV contains the static value, the MO operator is set to “equal” and the CDF is set to “not-sent”. 
<xref target="RFC7217"/> provides some methods that MAY be used to derive this static identifier.</t>

<t>If several IIDs are possible, then the TV contains the list of possible IIDs, the MO is 
set to “match-mapping” and the CDA is set to “mapping-sent”.</t>

<t>It may also happen that the IID variability only expresses itself on a few bytes. In that case, the TV is
set to the stable part of the IID, the MO is set to “MSB” and the CDA is set to “LSB”.</t>

<t>Finally, the IID can be sent in extenso on the LPWAN. In that case, the TV is not set, the MO is set
to “ignore” and the CDA is set to “value-sent”.</t>

</section>
</section>
<section anchor="ipv6-extensions" title="IPv6 extensions">

<t>No rule is currently defined that processes IPv6 extensions.
If such extensions are needed, their compression/decompression rules can be based on the MOs and
CDAs described above.</t>

</section>
<section anchor="udp-source-and-destination-port" title="UDP source and destination port">

<t>To allow for a single rule being used for both directions, the UDP port values are identified by their role
(DEV or APP) and not by their position in the frame (source or destination). The SCHC C/D
must be aware of the traffic direction (Uplink, Downlink) to select the appropriate
field. The following rules apply for DEV and APP port numbers.</t>

<t>If both ends know the port number, it can be elided. The TV contains the port number,
the MO is set to “equal” and the CDA is set to “not-sent”.</t>

<t>If the port variation is on few bits, the TV contains the stable part of the port number,
the MO is set to “MSB” and the CDA is set to “LSB”.</t>

<t>If some well-known values are used,  the TV can contain the list of these values, the
MO is set to “match-mapping” and the CDA is set to “mapping-sent”.</t>

<t>Otherwise the port numbers are sent over the LPWAN. The TV is not set, the MO is
set to “ignore” and the CDA is set to “value-sent”.</t>

</section>
<section anchor="udp-length-field" title="UDP length field">

<t>The UDP length can be computed from the received data. In that case, the TV is not set, the MO is set to “ignore” and
the CDA is set to “compute-length”.</t>

<t>If the payload is small, the TV can be set to 0x0000, the MO set to “MSB” and the
CDA to “LSB”.</t>

<t>In other cases, the length must be sent and the CDA is replaced by “value-sent”.</t>

</section>
<section anchor="udp-checksum-field" title="UDP Checksum field">

<t>IPv6 mandates a checksum in the protocol above IP. Nevertheless, if a more efficient
mechanism such as L2 CRC or MIC is carried by or over the L2 (such as in the
LPWAN fragmentation process (see <xref target="Frag"/>)), the UDP checksum transmission can be avoided.
In that case, the TV is not set, the MO is set to “ignore” and the CDA is set to
“compute-checksum”.</t>

<t>In other cases, the checksum must be explicitly sent. The TV is not set, the MO is set to
“ignore” and the CDF is set to “value-sent”.</t>

</section>
</section>
<section anchor="security-considerations" title="Security considerations">

<section anchor="security-considerations-for-header-compression" title="Security considerations for header compression">
<t>A malicious header compression could cause the reconstruction of a 
wrong packet that does not match with the original one. Such a corruption
may be detected with end-to-end authentication and integrity mechanisms. 
Header Compression does not add more security problem than what is already needed in a transmission. 
For instance, to avoid an attack, never re-construct a packet bigger than some configured size (with 1500 bytes as generic 
default).</t>

</section>
<section anchor="security-considerations-for-fragmentation" title="Security considerations for fragmentation">
<t>This subsection describes potential attacks to LPWAN fragmentation 
and suggests possible countermeasures.</t>

<t>A node can perform a buffer reservation attack by sending a first
fragment to a target.  Then, the receiver will reserve buffer space
for the IPv6 packet.  Other incoming fragmented packets will be
dropped while the reassembly buffer is occupied during the reassembly
timeout.  Once that timeout expires, the attacker can repeat the same
procedure, and iterate, thus creating a denial of service attack.
The (low) cost to mount this attack is linear with the number of
buffers at the target node.  However, the cost for an attacker can be
increased if individual fragments of multiple packets can be stored
in the reassembly buffer.  To further increase the attack cost, the
reassembly buffer can be splitted into fragment-sized buffer slots.
Once a packet is complete, it is processed normally.  If buffer
overload occurs, a receiver can discard packets based on the sender
behavior, which may help identify which fragments have been sent by
an attacker.</t>

<t>In another type of attack, the malicious node is required to have
overhearing capabilities.  If an attacker can overhear a fragment, it
can send a spoofed duplicate (e.g. with random payload) to the
destination. If the LPWAN technology does not support suitable protection 
(e.g. source authentication and frame counters to prevent replay attacks), 
a receiver cannot distinguish legitimate from spoofed fragments.  Therefore, 
the original IPv6 packet will be considered corrupt and will be dropped.
To protect resource-constrained nodes from this attack, it has been proposed
to establish a binding among the fragments to be transmitted by a node, 
by applying content-chaining to the different fragments, based on cryptographic
hash functionality.  The aim of this technique is to allow a receiver to
identify illegitimate fragments.</t>

<t>Further attacks may involve sending overlapped fragments (i.e.
comprising some overlapping parts of the original IPv6 datagram).
Implementers should make sure that the correct operation is not affected
by such event.</t>

<t>In Window mode – ACK on error, a malicious node may force a fragment sender to resend a fragment a number of times, with the aim to increase consumption of the fragment sender’s resources. To this end, the malicious node may repeatedly send a fake ACK to the fragment sender, with a Bitmap that reports that one or more fragments have been lost. In order to mitigate this possible attack, MAX_FRAG_RETRIES may be set to a safe value which allows to limit the maximum damage of the attack to an acceptable extent. However, note that a high setting for MAX_FRAG_RETRIES benefits fragment reliability modes, therefore the trade-off needs to be carefully considered.</t>

</section>
</section>
<section anchor="acknowledgements" title="Acknowledgements">

<t>Thanks to Dominique Barthel, Carsten Bormann, Philippe Clavier, Eduardo Ingles Sanchez, Arunprabhu Kandasamy, Rahul Jadhav,
Sergio Lopez Bernal, Antony Markovski, Alexander Pelov, Pascal Thubert, Juan Carlos Zuniga, Diego Dujovne, Edgar Ramos, and Shoichi Sakane for useful design consideration and comments.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor="RFC4944" target='https://www.rfc-editor.org/info/rfc4944'>
<front>
<title>Transmission of IPv6 Packets over IEEE 802.15.4 Networks</title>
<author initials='G.' surname='Montenegro' fullname='G. Montenegro'><organization /></author>
<author initials='N.' surname='Kushalnagar' fullname='N. Kushalnagar'><organization /></author>
<author initials='J.' surname='Hui' fullname='J. Hui'><organization /></author>
<author initials='D.' surname='Culler' fullname='D. Culler'><organization /></author>
<date year='2007' month='September' />
<abstract><t>This document describes the frame format for transmission of IPv6 packets and the method of forming IPv6 link-local addresses and statelessly autoconfigured addresses on IEEE 802.15.4 networks. Additional specifications include a simple header compression scheme using shared context and provisions for packet delivery in IEEE 802.15.4 meshes.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='4944'/>
<seriesInfo name='DOI' value='10.17487/RFC4944'/>
</reference>



<reference  anchor="RFC2460" target='https://www.rfc-editor.org/info/rfc2460'>
<front>
<title>Internet Protocol, Version 6 (IPv6) Specification</title>
<author initials='S.' surname='Deering' fullname='S. Deering'><organization /></author>
<author initials='R.' surname='Hinden' fullname='R. Hinden'><organization /></author>
<date year='1998' month='December' />
<abstract><t>This document specifies version 6 of the Internet Protocol (IPv6), also sometimes referred to as IP Next Generation or IPng.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='2460'/>
<seriesInfo name='DOI' value='10.17487/RFC2460'/>
</reference>



<reference  anchor="RFC3385" target='https://www.rfc-editor.org/info/rfc3385'>
<front>
<title>Internet Protocol Small Computer System Interface (iSCSI) Cyclic Redundancy Check (CRC)/Checksum Considerations</title>
<author initials='D.' surname='Sheinwald' fullname='D. Sheinwald'><organization /></author>
<author initials='J.' surname='Satran' fullname='J. Satran'><organization /></author>
<author initials='P.' surname='Thaler' fullname='P. Thaler'><organization /></author>
<author initials='V.' surname='Cavanna' fullname='V. Cavanna'><organization /></author>
<date year='2002' month='September' />
</front>
<seriesInfo name='RFC' value='3385'/>
<seriesInfo name='DOI' value='10.17487/RFC3385'/>
</reference>



<reference  anchor="RFC7136" target='https://www.rfc-editor.org/info/rfc7136'>
<front>
<title>Significance of IPv6 Interface Identifiers</title>
<author initials='B.' surname='Carpenter' fullname='B. Carpenter'><organization /></author>
<author initials='S.' surname='Jiang' fullname='S. Jiang'><organization /></author>
<date year='2014' month='February' />
<abstract><t>The IPv6 addressing architecture includes a unicast interface identifier that is used in the creation of many IPv6 addresses. Interface identifiers are formed by a variety of methods.  This document clarifies that the bits in an interface identifier have no meaning and that the entire identifier should be treated as an opaque value.  In particular, RFC 4291 defines a method by which the Universal and Group bits of an IEEE link-layer address are mapped into an IPv6 unicast interface identifier.  This document clarifies that those two bits are significant only in the process of deriving interface identifiers from an IEEE link-layer address, and it updates RFC 4291 accordingly.</t></abstract>
</front>
<seriesInfo name='RFC' value='7136'/>
<seriesInfo name='DOI' value='10.17487/RFC7136'/>
</reference>



<reference  anchor="RFC5795" target='https://www.rfc-editor.org/info/rfc5795'>
<front>
<title>The RObust Header Compression (ROHC) Framework</title>
<author initials='K.' surname='Sandlund' fullname='K. Sandlund'><organization /></author>
<author initials='G.' surname='Pelletier' fullname='G. Pelletier'><organization /></author>
<author initials='L-E.' surname='Jonsson' fullname='L-E. Jonsson'><organization /></author>
<date year='2010' month='March' />
<abstract><t>The Robust Header Compression (ROHC) protocol provides an efficient, flexible, and future-proof header compression concept.  It is designed to operate efficiently and robustly over various link technologies with different characteristics.</t><t>The ROHC framework, along with a set of compression profiles, was initially defined in RFC 3095.  To improve and simplify the ROHC specifications, this document explicitly defines the ROHC framework and the profile for uncompressed separately.  More specifically, the definition of the framework does not modify or update the definition of the framework specified by RFC 3095.</t><t>This specification obsoletes RFC 4995.  It fixes one interoperability issue that was erroneously introduced in RFC 4995, and adds some minor clarifications.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5795'/>
<seriesInfo name='DOI' value='10.17487/RFC5795'/>
</reference>



<reference  anchor="RFC7217" target='https://www.rfc-editor.org/info/rfc7217'>
<front>
<title>A Method for Generating Semantically Opaque Interface Identifiers with IPv6 Stateless Address Autoconfiguration (SLAAC)</title>
<author initials='F.' surname='Gont' fullname='F. Gont'><organization /></author>
<date year='2014' month='April' />
<abstract><t>This document specifies a method for generating IPv6 Interface Identifiers to be used with IPv6 Stateless Address Autoconfiguration (SLAAC), such that an IPv6 address configured using this method is stable within each subnet, but the corresponding Interface Identifier changes when the host moves from one network to another.  This method is meant to be an alternative to generating Interface Identifiers based on hardware addresses (e.g., IEEE LAN Media Access Control (MAC) addresses), such that the benefits of stable addresses can be achieved without sacrificing the security and privacy of users.  The method specified in this document applies to all prefixes a host may be employing, including link-local, global, and unique-local prefixes (and their corresponding addresses).</t></abstract>
</front>
<seriesInfo name='RFC' value='7217'/>
<seriesInfo name='DOI' value='10.17487/RFC7217'/>
</reference>




    </references>

    <references title='Informative References'>





<reference anchor="I-D.ietf-lpwan-overview">
<front>
<title>LPWAN Overview</title>

<author initials='S' surname='Farrell' fullname='Stephen Farrell'>
    <organization />
</author>

<date month='February' day='7' year='2018' />

<abstract><t>Low Power Wide Area Networks (LPWAN) are wireless technologies with characteristics such as large coverage areas, low bandwidth, possibly very small packet and application layer data sizes and long battery life operation.  This memo is an informational overview of the set of LPWAN technologies being considered in the IETF and of the gaps that exist between the needs of those technologies and the goal of running IP in LPWANs.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-lpwan-overview-10' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-lpwan-overview-10.txt' />
</reference>



<reference anchor="I-D.zuniga-lpwan-schc-over-sigfox">
<front>
<title>SCHC over Sigfox LPWAN</title>

<author initials='J' surname='Zuniga' fullname='Juan Zuniga'>
    <organization />
</author>

<author initials='C' surname='Gomez' fullname='Carles Gomez'>
    <organization />
</author>

<author initials='L' surname='Toutain' fullname='Laurent Toutain'>
    <organization />
</author>

<date month='October' day='30' year='2017' />

<abstract><t>The Static Context Header Compression (SCHC) specification describes a header compression scheme and fragmentation functionality for LPWAN (Low Power Wide Area Network) technologies.  SCHC offers a great level of flexibility that can be tailored for different LPWAN technologies.  The present document provides the optimal parameters and modes of operation when SCHC is implemented over a Sigfox LPWAN.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-zuniga-lpwan-schc-over-sigfox-00' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-zuniga-lpwan-schc-over-sigfox-00.txt' />
</reference>



<reference anchor="I-D.petrov-lpwan-ipv6-schc-over-lorawan">
<front>
<title>Static Context Header Compression (SCHC) over LoRaWAN</title>

<author initials='I' surname='Petrov' fullname='Ivaylo Petrov'>
    <organization />
</author>

<author initials='A' surname='Yegin' fullname='Alper Yegin'>
    <organization />
</author>

<date month='October' day='30' year='2017' />

<abstract><t>The Static Context Header Compression (SCHC) specification describes generic header compression and fragmentation techniques for LPWAN (Low Power Wide Area Networks) technologies.  SCHC is a generic mechanism designed for great flexibility, so that it can be adapted for any of the LPWAN technologies.  This document provides the adaptation of SCHC for use in LoRaWAN networks, and provides elements such as efficient parameterization and modes of operation.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-petrov-lpwan-ipv6-schc-over-lorawan-00' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-petrov-lpwan-ipv6-schc-over-lorawan-00.txt' />
</reference>




    </references>


<section anchor="compressIPv6" title="SCHC Compression Examples">

<t>This section gives some scenarios of the compression mechanism for IPv6/UDP.
The goal is to illustrate the behavior of SCHC.</t>

<t>The most common case using the mechanisms defined in this document will be a 
LPWAN Dev that embeds some applications running over
CoAP. In this example, three flows are considered. The first flow is for the device management based
on CoAP using
Link Local IPv6 addresses and UDP ports 123 and 124 for Dev and App, respectively.
The second flow will be a CoAP server for measurements done by the Device
(using ports 5683) and Global IPv6 Address prefixes alpha::IID/64 to beta::1/64.
The last flow is for legacy applications using different ports numbers, the
destination IPv6 address prefix is gamma::1/64.</t>

<t><xref target="FigStack"/> presents the protocol stack for this Device. IPv6 and UDP are represented
with dotted lines since these protocols are compressed on the radio link.</t>

<figure title="Simplified Protocol Stack for LP-WAN" anchor="FigStack"><artwork><![CDATA[
 Management   Data
+----------+---------+---------+
|   CoAP   |  CoAP   | legacy  |
+----||----+---||----+---||----+
.   UDP    .  UDP    |   UDP   |
................................
.   IPv6   .  IPv6   .  IPv6   .
+------------------------------+
|    SCHC Header compression   |
|      and fragmentation       |
+------------------------------+
|      LPWAN L2 technologies   |
+------------------------------+
         DEV or NGW

]]></artwork></figure>

<t>Note that in some LPWAN technologies, only the Devs have a device ID.
Therefore, when such technologies are used, it is necessary to statically define an IID for the Link
Local address for the SCHC C/D.</t>

<figure title="Context rules" anchor="Fig-fields"><artwork><![CDATA[
Rule 0
 +----------------+--+--+--+---------+--------+------------++------+
 | Field          |FL|FP|DI| Value   | Match  | Comp Decomp|| Sent |
 |                |  |  |  |         | Opera. | Action     ||[bits]|
 +----------------+--+--+--+---------+---------------------++------+
 |IPv6 version    |4 |1 |Bi|6        | equal  | not-sent   ||      |
 |IPv6 DiffServ   |8 |1 |Bi|0        | equal  | not-sent   ||      |
 |IPv6 Flow Label |20|1 |Bi|0        | equal  | not-sent   ||      |
 |IPv6 Length     |16|1 |Bi|         | ignore | comp-length||      |
 |IPv6 Next Header|8 |1 |Bi|17       | equal  | not-sent   ||      |
 |IPv6 Hop Limit  |8 |1 |Bi|255      | ignore | not-sent   ||      |
 |IPv6 DEVprefix  |64|1 |Bi|FE80::/64| equal  | not-sent   ||      |
 |IPv6 DEViid     |64|1 |Bi|         | ignore | DEViid     ||      |
 |IPv6 APPprefix  |64|1 |Bi|FE80::/64| equal  | not-sent   ||      |
 |IPv6 APPiid     |64|1 |Bi|::1      | equal  | not-sent   ||      |
 +================+==+==+==+=========+========+============++======+
 |UDP DEVport     |16|1 |Bi|123      | equal  | not-sent   ||      |
 |UDP APPport     |16|1 |Bi|124      | equal  | not-sent   ||      |
 |UDP Length      |16|1 |Bi|         | ignore | comp-length||      |
 |UDP checksum    |16|1 |Bi|         | ignore | comp-chk   ||      |
 +================+==+==+==+=========+========+============++======+

 Rule 1
 +----------------+--+--+--+---------+--------+------------++------+
 | Field          |FL|FP|DI| Value   | Match  | Action     || Sent |
 |                |  |  |  |         | Opera. | Action     ||[bits]|
 +----------------+--+--+--+---------+--------+------------++------+
 |IPv6 version    |4 |1 |Bi|6        | equal  | not-sent   ||      |
 |IPv6 DiffServ   |8 |1 |Bi|0        | equal  | not-sent   ||      |
 |IPv6 Flow Label |20|1 |Bi|0        | equal  | not-sent   ||      |
 |IPv6 Length     |16|1 |Bi|         | ignore | comp-length||      |
 |IPv6 Next Header|8 |1 |Bi|17       | equal  | not-sent   ||      |
 |IPv6 Hop Limit  |8 |1 |Bi|255      | ignore | not-sent   ||      |
 |IPv6 DEVprefix  |64|1 |Bi|[alpha/64, match- |mapping-sent||  [1] |
 |                |  |  |  |fe80::/64] mapping|            ||      |
 |IPv6 DEViid     |64|1 |Bi|         | ignore | DEViid     ||      |
 |IPv6 APPprefix  |64|1 |Bi|[beta/64,| match- |mapping-sent||  [2] |
 |                |  |  |  |alpha/64,| mapping|            ||      |
 |                |  |  |  |fe80::64]|        |            ||      |
 |IPv6 APPiid     |64|1 |Bi|::1000   | equal  | not-sent   ||      |
 +================+==+==+==+=========+========+============++======+
 |UDP DEVport     |16|1 |Bi|5683     | equal  | not-sent   ||      |
 |UDP APPport     |16|1 |Bi|5683     | equal  | not-sent   ||      |
 |UDP Length      |16|1 |Bi|         | ignore | comp-length||      |
 |UDP checksum    |16|1 |Bi|         | ignore | comp-chk   ||      |
 +================+==+==+==+=========+========+============++======+
 
 Rule 2
 +----------------+--+--+--+---------+--------+------------++------+
 | Field          |FL|FP|DI| Value   | Match  | Action     || Sent |
 |                |  |  |  |         | Opera. | Action     ||[bits]|
 +----------------+--+--+--+---------+--------+------------++------+
 |IPv6 version    |4 |1 |Bi|6        | equal  | not-sent   ||      |
 |IPv6 DiffServ   |8 |1 |Bi|0        | equal  | not-sent   ||      |
 |IPv6 Flow Label |20|1 |Bi|0        | equal  | not-sent   ||      |
 |IPv6 Length     |16|1 |Bi|         | ignore | comp-length||      |
 |IPv6 Next Header|8 |1 |Bi|17       | equal  | not-sent   ||      |
 |IPv6 Hop Limit  |8 |1 |Up|255      | ignore | not-sent   ||      |
 |IPv6 Hop Limit  |8 |1 |Dw|         | ignore | value-sent ||  [8] |
 |IPv6 DEVprefix  |64|1 |Bi|alpha/64 | equal  | not-sent   ||      |
 |IPv6 DEViid     |64|1 |Bi|         | ignore | DEViid     ||      |
 |IPv6 APPprefix  |64|1 |Bi|gamma/64 | equal  | not-sent   ||      |
 |IPv6 APPiid     |64|1 |Bi|::1000   | equal  | not-sent   ||      |
 +================+==+==+==+=========+========+============++======+
 |UDP DEVport     |16|1 |Bi|8720     | MSB(12)| LSB(4)     || [4]  |
 |UDP APPport     |16|1 |Bi|8720     | MSB(12)| LSB(4)     || [4]  |
 |UDP Length      |16|1 |Bi|         | ignore | comp-length||      |
 |UDP checksum    |16|1 |Bi|         | ignore | comp-chk   ||      |
 +================+==+==+==+=========+========+============++======+


]]></artwork></figure>

<t>All the fields described in the three rules depicted on <xref target="Fig-fields"/> are present
in the IPv6 and UDP headers.  The DEViid-DID value is found in the L2
header.</t>

<t>The second and third rules use global addresses. The way the Dev learns the
prefix is not in the scope of the document.</t>

<t>The third rule compresses port numbers to 4 bits.</t>

</section>
<section anchor="fragmentation-examples" title="Fragmentation Examples">

<t>This section provides examples for the different fragment reliability modes specified in this document.</t>

<t><xref target="Fig-Example-Unreliable"/> illustrates the transmission in No-ACK mode of an IPv6 packet that needs 11 fragments. FCN is 1 bit wide.</t>

<figure title="Transmission in No-ACK mode of an IPv6 packet carried by 11 fragments" anchor="Fig-Example-Unreliable"><artwork><![CDATA[
        Sender               Receiver
          |-------FCN=0-------->|
          |-------FCN=0-------->|
          |-------FCN=0-------->|
          |-------FCN=0-------->|
          |-------FCN=0-------->|
          |-------FCN=0-------->|
          |-------FCN=0-------->|
          |-------FCN=0-------->|
          |-------FCN=0-------->|
          |-------FCN=0-------->|
          |-----FCN=1 + MIC --->|MIC checked: success =>
         
]]></artwork></figure>

<t>In the following examples, N (i.e. the size if the FCN field) is 3 bits. Therefore, the All-1 FCN value is 7.</t>

<t><xref target="Fig-Example-Win-NoLoss-NACK"/> illustrates the transmission in ACK-on-Error of an IPv6 packet that needs 11 fragments, with MAX_WIND_FCN=6 and no fragment loss.</t>

<figure title="Transmission in ACK-on-Error mode of an IPv6 packet carried by 11 fragments, with MAX_WIND_FCN=6 and no loss." anchor="Fig-Example-Win-NoLoss-NACK"><artwork><![CDATA[
        Sender               Receiver
          |-----W=0, FCN=6----->|
          |-----W=0, FCN=5----->|
          |-----W=0, FCN=4----->|
          |-----W=0, FCN=3----->|
          |-----W=0, FCN=2----->|
          |-----W=0, FCN=1----->|
          |-----W=0, FCN=0----->|
      (no ACK)
          |-----W=1, FCN=6----->|
          |-----W=1, FCN=5----->|
          |-----W=1, FCN=4----->|
          |--W=1, FCN=7 + MIC-->|MIC checked: success =>
          |<---- ACK, W=1 ------|

]]></artwork></figure>

<t><xref target="Fig-Example-Rel-Window-NACK-Loss"/> illustrates the transmission in ACK-on-Error mode of an IPv6 packet that needs 11 fragments, with MAX_WIND_FCN=6 and three lost fragments.</t>

<figure title="Transmission in ACK-on-Error mode of an IPv6 packet carried by 11 fragments, with MAX_WIND_FCN=6 and three lost fragments." anchor="Fig-Example-Rel-Window-NACK-Loss"><artwork><![CDATA[
         Sender             Receiver
          |-----W=0, FCN=6----->|
          |-----W=0, FCN=5----->|
          |-----W=0, FCN=4--X-->|
          |-----W=0, FCN=3----->|
          |-----W=0, FCN=2--X-->|             7
          |-----W=0, FCN=1----->|             /
          |-----W=0, FCN=0----->|       6543210
          |<-----ACK, W=0-------|Bitmap:1101011
          |-----W=0, FCN=4----->|
          |-----W=0, FCN=2----->|   
      (no ACK)     
          |-----W=1, FCN=6----->|
          |-----W=1, FCN=5----->|
          |-----W=1, FCN=4--X-->|
          |- W=1, FCN=7 + MIC ->|MIC checked: failed
          |<-----ACK, W=1-------|C=0 Bitmap:1100001
          |-----W=1, FCN=4----->|MIC checked: success =>
          |<---- ACK, W=1 ------|C=1, no Bitmap

]]></artwork></figure>

<t><xref target="Fig-Example-Rel-Window-ACK-NoLoss"/> illustrates the transmission in ACK-Always mode of an IPv6 packet that needs 11 fragments, with MAX_WIND_FCN=6 and no loss.</t>

<figure title="Transmission in ACK-Always mode of an IPv6 packet carried by 11 fragments, with MAX_WIND_FCN=6 and no lost fragment." anchor="Fig-Example-Rel-Window-ACK-NoLoss"><artwork><![CDATA[
        Sender               Receiver
          |-----W=0, FCN=6----->|
          |-----W=0, FCN=5----->|
          |-----W=0, FCN=4----->|
          |-----W=0, FCN=3----->|
          |-----W=0, FCN=2----->|
          |-----W=0, FCN=1----->|
          |-----W=0, FCN=0----->|
          |<-----ACK, W=0-------| Bitmap:1111111
          |-----W=1, FCN=6----->|
          |-----W=1, FCN=5----->|   
          |-----W=1, FCN=4----->|
          |--W=1, FCN=7 + MIC-->|MIC checked: success =>
          |<-----ACK, W=1-------| C=1 no Bitmap
        (End)    

]]></artwork></figure>

<t><xref target="Fig-Example-Rel-Window-ACK-Loss"/> illustrates the transmission in ACK-Always mode of an IPv6 packet that needs 11 fragments, with MAX_WIND_FCN=6 and three lost fragments.</t>

<figure title="Transmission in ACK-Always mode of an IPv6 packet carried by 11 fragments, with MAX_WIND_FCN=6 and three lost fragments." anchor="Fig-Example-Rel-Window-ACK-Loss"><artwork><![CDATA[
        Sender               Receiver
          |-----W=1, FCN=6----->|
          |-----W=1, FCN=5----->|
          |-----W=1, FCN=4--X-->|
          |-----W=1, FCN=3----->|
          |-----W=1, FCN=2--X-->|             7
          |-----W=1, FCN=1----->|             /
          |-----W=1, FCN=0----->|       6543210
          |<-----ACK, W=1-------|Bitmap:1101011
          |-----W=1, FCN=4----->|
          |-----W=1, FCN=2----->|
          |<-----ACK, W=1-------|Bitmap:
          |-----W=0, FCN=6----->|
          |-----W=0, FCN=5----->|   
          |-----W=0, FCN=4--X-->|
          |--W=0, FCN=7 + MIC-->|MIC checked: failed
          |<-----ACK, W=0-------| C= 0 Bitmap:11000001
          |-----W=0, FCN=4----->|MIC checked: success =>
          |<-----ACK, W=0-------| C= 1 no Bitmap
        (End)    

]]></artwork></figure>

<t><xref target="Fig-Example-Rel-Window-ACK-Loss-Last-A"/> illustrates the transmission in ACK-Always mode of an IPv6 packet that needs 6 fragments, with MAX_WIND_FCN=6, three lost fragments and only one retry needed to recover each lost fragment.</t>

<figure title="Transmission in ACK-Always mode of an IPv6 packet carried by 11 fragments, fwith MAX_WIND_FCN=6, three lost framents and only one retry needed for each lost fragment." anchor="Fig-Example-Rel-Window-ACK-Loss-Last-A"><artwork><![CDATA[
          Sender                Receiver
             |-----W=0, FCN=6----->|
             |-----W=0, FCN=5----->|
             |-----W=0, FCN=4--X-->|
             |-----W=0, FCN=3--X-->|
             |-----W=0, FCN=2--X-->|
             |--W=0, FCN=7 + MIC-->|MIC checked: failed
             |<-----ACK, W=0-------|C= 0 Bitmap:1100001
             |-----W=0, FCN=4----->|MIC checked: failed
             |-----W=0, FCN=3----->|MIC checked: failed
             |-----W=0, FCN=2----->|MIC checked: success
             |<-----ACK, W=0-------|C=1 no Bitmap
           (End) 
]]></artwork></figure>

<t><xref target="Fig-Example-Rel-Window-ACK-Loss-Last-B"/> illustrates the transmission in ACK-Always mode of an IPv6 packet that needs 6 fragments, with MAX_WIND_FCN=6, three lost fragments, and the second ACK lost.</t>

<figure title="Transmission in ACK-Always mode of an IPv6 packet carried by 11 fragments, with MAX_WIND_FCN=6, three lost fragments, and the second ACK lost." anchor="Fig-Example-Rel-Window-ACK-Loss-Last-B"><artwork><![CDATA[
          Sender                Receiver
             |-----W=0, FCN=6----->|
             |-----W=0, FCN=5----->|
             |-----W=0, FCN=4--X-->|
             |-----W=0, FCN=3--X-->|
             |-----W=0, FCN=2--X-->|
             |--W=0, FCN=7 + MIC-->|MIC checked: failed
             |<-----ACK, W=0-------|C=0  Bitmap:1100001
             |-----W=0, FCN=4----->|MIC checked: failed
             |-----W=0, FCN=3----->|MIC checked: failed
             |-----W=0, FCN=2----->|MIC checked: success
             |  X---ACK, W=0-------|C= 1 no Bitmap
    timeout  |                     |
             |--W=0, FCN=7 + MIC-->|
             |<-----ACK, W=0-------|C= 1 no Bitmap  

           (End) 
]]></artwork></figure>

<t><xref target="Fig-Example-Rel-Window-ACK-Loss-Last-C"/> illustrates the transmission in ACK-Always mode of an IPv6 packet that needs 6 fragments, with MAX_WIND_FCN=6, with three lost fragments, and one retransmitted fragment lost again.</t>

<figure title="Transmission in ACK-Always mode of an IPv6 packet carried by 11 fragments, with MAX_WIND_FCN=6, with three lost fragments, and one retransmitted fragment lost again." anchor="Fig-Example-Rel-Window-ACK-Loss-Last-C"><artwork><![CDATA[
           Sender                Receiver
             |-----W=0, FCN=6----->|
             |-----W=0, FCN=5----->|
             |-----W=0, FCN=4--X-->|
             |-----W=0, FCN=3--X-->|
             |-----W=0, FCN=2--X-->|
             |--W=0, FCN=7 + MIC-->|MIC checked: failed
             |<-----ACK, W=0-------|C=0 Bitmap:1100001
             |-----W=0, FCN=4----->|MIC checked: failed
             |-----W=0, FCN=3----->|MIC checked: failed
             |-----W=0, FCN=2--X-->|
      timeout|                     |
             |--W=0, FCN=7 + MIC-->|All-0 empty
             |<-----ACK, W=0-------|C=0 Bitmap: 1111101
             |-----W=0, FCN=2----->|MIC checked: success
             |<-----ACK, W=0-------|C=1 no Bitmap
           (End) 
]]></artwork></figure>

<t><xref target="Fig-Example-MaxWindFCN"/> illustrates the transmission in ACK-Always mode of an IPv6 packet that needs 28 fragments, with N=5, MAX_WIND_FCN=23 and two lost fragments. Note that MAX_WIND_FCN=23 may be useful when the maximum possible Bitmap size, considering the maximum lower layer technology payload size and the value of R, is 3 bytes. Note also that the FCN of the last fragment of the packet is the one with FCN=31 (i.e. FCN=2^N-1 for N=5, or equivalently, all FCN bits set to 1).</t>

<figure title="Transmission in ACK-Always mode of an IPv6 packet carried by 28 fragments, with N=5, MAX_WIND_FCN=23 and two lost fragments." anchor="Fig-Example-MaxWindFCN"><artwork><![CDATA[
           Sender               Receiver
             |-----W=0, FCN=23----->|
             |-----W=0, FCN=22----->|
             |-----W=0, FCN=21--X-->|
             |-----W=0, FCN=20----->|
             |-----W=0, FCN=19----->|
             |-----W=0, FCN=18----->|
             |-----W=0, FCN=17----->|
             |-----W=0, FCN=16----->|
             |-----W=0, FCN=15----->|
             |-----W=0, FCN=14----->|
             |-----W=0, FCN=13----->|
             |-----W=0, FCN=12----->|
             |-----W=0, FCN=11----->|
             |-----W=0, FCN=10--X-->|
             |-----W=0, FCN=9 ----->|
             |-----W=0, FCN=8 ----->|
             |-----W=0, FCN=7 ----->|
             |-----W=0, FCN=6 ----->|
             |-----W=0, FCN=5 ----->|
             |-----W=0, FCN=4 ----->|
             |-----W=0, FCN=3 ----->|
             |-----W=0, FCN=2 ----->|
             |-----W=0, FCN=1 ----->|
             |-----W=0, FCN=0 ----->|
             |                      |lcl-Bitmap:110111111111101111111111
             |<------ACK, W=0-------|encoded Bitmap:1101111111111011
             |-----W=0, FCN=21----->|
             |-----W=0, FCN=10----->|
             |<------ACK, W=0-------|no Bitmap
             |-----W=1, FCN=23----->|
             |-----W=1, FCN=22----->|
             |-----W=1, FCN=21----->|
             |--W=1, FCN=31 + MIC-->|MIC checked: sucess =>
             |<------ACK, W=1-------|no Bitmap
           (End)
]]></artwork></figure>

</section>
<section anchor="FSM" title="Fragmentation State Machines">

<t>The fragmentation state machines of the sender and the receiver, one for each of the different reliability modes, are described in the following figures:</t>

<figure title="Sender State Machine for the No-ACK Mode" anchor="Fig-NoACKModeSnd"><artwork><![CDATA[
             +===========+
+------------+  Init     |                                      
|  FCN=0     +===========+                                      
|  No Window                                       
|  No Bitmap                                                      
|                   +-------+           
|          +========+==+    | More Fragments                 
|          |           | <--+ ~~~~~~~~~~~~~~~~~~~~                          
+--------> |   Send    |      send Fragment (FCN=0)                            
           +===+=======+                                                                      
               |  last fragment 
               |  ~~~~~~~~~~~~                               
               |  FCN = 1                               
               v  send fragment+MIC 
           +============+                                             
           |    END     |                                             
           +============+                       
]]></artwork></figure>

<figure title="Receiver State Machine for the No-ACK Mode" anchor="Fig-NoACKModeRcv"><artwork><![CDATA[
                      +------+ Not All-1
           +==========+=+    | ~~~~~~~~~~~~~~~~~~~
           |            + <--+ set Inactivity Timer
           |  RCV Frag  +-------+
           +=+===+======+       |All-1 &
   All-1 &   |   |              |MIC correct
 MIC wrong   |   |Inactivity    |
             |   |Timer Exp.    |
             v   |              |
  +==========++  |              v
  |   Error   |<-+     +========+==+
  +===========+        |    END    |
                       +===========+ 
                                           
]]></artwork></figure>

<figure title="Sender State Machine for the ACK-Always Mode" anchor="Fig-ACKAlwaysSnd"><artwork><![CDATA[
              +=======+  
              | INIT  |       FCN!=0 & more frags
              |       |       ~~~~~~~~~~~~~~~~~~~~~~
              +======++  +--+ send Window + frag(FCN)
                 W=0 |   |  | FCN-
  Clear local Bitmap |   |  v set local Bitmap
       FCN=max value |  ++==+========+
                     +> |            |
+---------------------> |    SEND    |
|                       +==+===+=====+ 
|      FCN==0 & more frags |   | last frag
|    ~~~~~~~~~~~~~~~~~~~~~ |   | ~~~~~~~~~~~~~~~
|         set local-Bitmap |   | set local-Bitmap 
|   send wnd + frag(all-0) |   | send wnd+frag(all-1)+MIC 
|       set Retrans_Timer  |   | set Retrans_Timer 
|                          |   | 
|Recv_wnd == wnd &         |   |  
|Lcl_Bitmap==recv_Bitmap&  |   |  +------------------------+
|more frag                 |   |  |local-Bitmap!=rcv-Bitmap|
|~~~~~~~~~~~~~~~~~~~~~~    |   |  | ~~~~~~~~~              |
|Stop Retrans_Timer        |   |  | Attemp++               v
|clear local_Bitmap        v   v  |                 +======++
|window=next_window   +====+===+==+===+             |Resend |
+---------------------+               |             |Missing|
                 +----+     Wait      |             |Frag   |
not expected wnd |    |    Bitmap     |             +=======+
~~~~~~~~~~~~~~~~ +--->+               +-+Retrans_Timer Exp  |          
    discard frag      +==+=+===+=+==+=+ |~~~~~~~~~~~~~~~~~  |
                         | |   | ^  ^   |reSend(empty)All-* |   
                         | |   | |  |   |Set Retrans_Timer  |
MIC_bit==1 &             | |   | |  +---+Attemp++           |
Recv_window==window &    | |   | +--------------------------+   
Lcl_Bitmap==recv_Bitmap &| |   |   all missing frag sent
             no more frag| |   |   ~~~~~~~~~~~~~~~~~~~~~~ 
 ~~~~~~~~~~~~~~~~~~~~~~~~| |   |   Set Retrans_Timer                 
       Stop Retrans_Timer| |   |    
 +=============+         | |   |
 |     END     +<--------+ |   | Attemp > MAX_ACK_REQUESTS
 +=============+           |   | ~~~~~~~~~~~~~~~~~~
              All-1 Window |   v Send Abort
              ~~~~~~~~~~~~ | +=+===========+
             MIC_bit ==0 & +>|    ERROR    |
    Lcl_Bitmap==recv_Bitmap  +=============+ 
    
    
]]></artwork></figure>

<figure title="Receiver State Machine for the ACK-Always Mode" anchor="Fig-ACKAlwaysRcv"><artwork><![CDATA[
 Not All- & w=expected +---+   +---+w = Not expected
 ~~~~~~~~~~~~~~~~~~~~~ |   |   |   |~~~~~~~~~~~~~~~~
 Set local_Bitmap(FCN) |   v   v   |discard
                      ++===+===+===+=+      
+---------------------+     Rcv      +--->* ABORT 
|  +------------------+   Window     |
|  |                  +=====+==+=====+  
|  |       All-0 & w=expect |  ^ w =next & not-All
|  |     ~~~~~~~~~~~~~~~~~~ |  |~~~~~~~~~~~~~~~~~~~~~
|  |     set lcl_Bitmap(FCN)|  |expected = next window
|  |      send local_Bitmap |  |Clear local_Bitmap
|  |                        |  |    
|  | w=expct & not-All      |  |    
|  | ~~~~~~~~~~~~~~~~~~     |  | 
|  | set lcl_Bitmap(FCN)+-+ |  | +--+ w=next & All-0
|  | if lcl_Bitmap full | | |  | |  | ~~~~~~~~~~~~~~~
|  | send lcl_Bitmap    | | |  | |  | expct = nxt wnd
|  |                    v | v  | |  | Clear lcl_Bitmap
|  |  w=expct & All-1 +=+=+=+==+=++ | set lcl_Bitmap(FCN)     
|  |  ~~~~~~~~~~~  +->+    Wait   +<+ send lcl_Bitmap       
|  |    discard    +--|    Next   |   
|  | All-0  +---------+  Window   +--->* ABORT  
|  | ~~~~~  +-------->+========+=++        
|  | snd lcl_bm  All-1 & w=next| |  All-1 & w=nxt
|  |                & MIC wrong| |  & MIC right      
|  |          ~~~~~~~~~~~~~~~~~| | ~~~~~~~~~~~~~~~~~~ 
|  |      set local_Bitmap(FCN)| |set lcl_Bitmap(FCN)       
|  |          send local_Bitmap| |send local_Bitmap 
|  |                           | +----------------------+
|  |All-1 & w=expct            |                        |
|  |& MIC wrong                v   +---+ w=expctd &     |
|  |~~~~~~~~~~~~~~~~~~~~  +====+=====+ | MIC wrong      |
|  |set local_Bitmap(FCN) |          +<+ ~~~~~~~~~~~~~~ |
|  |send local_Bitmap     | Wait End | set lcl_btmp(FCN)|
|  +--------------------->+          +--->* ABORT       |
|                         +===+====+=+-+ All-1&MIC wrong|
|                             |    ^   | ~~~~~~~~~~~~~~~|
|      w=expected & MIC right |    +---+ send lcl_btmp  |                
|      ~~~~~~~~~~~~~~~~~~~~~~ |                         |
|       set local_Bitmap(FCN) | +-+ Not All-1           |
|        send local_Bitmap    | | | ~~~~~~~~~           |
|                             | | |  discard            |
|All-1 & w=expctd & MIC right | | |                     |
|~~~~~~~~~~~~~~~~~~~~~~~~~~~~ v | v +----+All-1         |
|set local_Bitmap(FCN)      +=+=+=+=+==+ |~~~~~~~~~     |
|send local_Bitmap          |          +<+Send lcl_btmp |
+-------------------------->+    END   |                |
                            +==========+<---------------+
                            
       --->* ABORT
            ~~~~~~~
            Inactivity_Timer = expires
        When DWN_Link
          IF Inactivity_Timer expires
             Send DWL Request
             Attemp++
                            
]]></artwork></figure>

<figure title="Sender State Machine for the ACK-on-Error Mode" anchor="Fig-ACKonerrorSnd"><artwork><![CDATA[
                   +=======+  
                   |       |  
                   | INIT  |  
                   |       |        FCN!=0 & more frags
                   +======++  +--+  ~~~~~~~~~~~~~~~~~~~~~~
                      W=0 |   |  |  send Window + frag(FCN)
       ~~~~~~~~~~~~~~~~~~ |   |  |  FCN-
       Clear local Bitmap |   |  v  set local Bitmap
            FCN=max value |  ++=============+
                          +> |              |
                             |     SEND     |
 +-------------------------> |              |
 |                           ++=====+=======+
 |         FCN==0 & more frags|     |last frag
 |     ~~~~~~~~~~~~~~~~~~~~~~~|     |~~~~~~~~~~~~~~~~~~~~~~~~
 |            set local-Bitmap|     |set local-Bitmap
 |      send wnd + frag(all-0)|     |send wnd+frag(all-1)+MIC
 |           set Retrans_Timer|     |set Retrans_Timer
 |                            |     |
 |Retrans_Timer expires &     |     | local-Bitmap!=rcv-Bitmap 
 |more fragments              |     |  +-----------------+
 |~~~~~~~~~~~~~~~~~~~~        |     |  | ~~~~~~~~~~~~~   |
 |stop Retrans_Timer          |     |  | Attemp++        |
 |clear local-Bitmap          v     v  |                 v
 |window = next window  +=====+=====+==+==+         +====+====+
 +----------------------+                 +         | Resend  |
 +--------------------->+    Wait Bitmap  |         | Missing |
 |                  +-- +                 |         | Frag    |
 | not expected wnd |   ++=+===+===+===+==+         +======+==+
 | ~~~~~~~~~~~~~~~~ |    ^ |   |   |   ^                   |
 |    discard frag  +----+ |   |   |   +-------------------+
 |                         |   |   |     all missing frag sent
 |Retrans_Timer expires &  |   |   |     ~~~~~~~~~~~~~~~~~~~~~ 
 |       No more Frag      |   |   |     Set Retrans_Timer
 | ~~~~~~~~~~~~~~~~~~~~~~~ |   |   |   
 |  Stop Retrans_Timer     |   |   |  
 |  Send ALL-1-empty       |   |   | 
 +-------------------------+   |   | 
                               |   |
      Local_Bitmap==Recv_Bitmap|   |
      ~~~~~~~~~~~~~~~~~~~~~~~~~|   |Attemp > MAX_ACK_REQUESTS
 +=========+Stop Retrans_Timer |   |~~~~~~~~~~~~~~~~~~~~~~~
 |   END   +<------------------+   v  Send Abort
 +=========+                     +=+=========+
                                 |   ERROR   |
                                 +===========+                                      
]]></artwork></figure>

<figure title="Receiver State Machine for the ACK-on-Error Mode" anchor="Fig-ACKonerrorRcv"><artwork><![CDATA[
   Not All- & w=expected +---+   +---+w = Not expected
   ~~~~~~~~~~~~~~~~~~~~~ |   |   |   |~~~~~~~~~~~~~~~~ 
   Set local_Bitmap(FCN) |   v   v   |discard
                        ++===+===+===+=+
+-----------------------+              +--+ All-0 & full 
|            ABORT *<---+  Rcv Window  |  | ~~~~~~~~~~~~ 
|  +--------------------+              +<-+ w =next
|  |     All-0 empty +->+=+=+===+======+ clear lcl_Bitmap
|  |     ~~~~~~~~~~~ |    | |   ^
|  |     send bitmap +----+ |   |w=expct & not-All & full
|  |                        |   |~~~~~~~~~~~~~~~~~~~~~~~~
|  |                        |   |set lcl_Bitmap; w =nxt
|  |                        |   |     
|  |      All-0 & w=expect  |   |     w=next   +=+======+
|  |      & no_full Bitmap  |   |    ~~~~~~~~  |        | 
|  |      ~~~~~~~~~~~~~~~~~ |   |  +---------->+ Error/ |
|  |      send local_Bitmap |   |  | Send abort| Abort  |
|  |                        |   |  |     +---->++=======+
|  |                        v   |  | +---+ w=expct   ^
|  |    All-0 empty    +=+===+==+==+=+=+  & all-1    |
|  |  ~~~~~~~~~~~~~ +--+    Wait       |  ~~~~~~~    |
|  |  send lcl_btmp +->| Missing Fragm.|  Send abort |
|  |                   +==============++             |
|  |                                  +--------------+
|  |                                   Uplink Only &
|  |                             Inactivity_Timer = expires
|  |                             ~~~~~~~~~~~~~~~~~~~~~~~~~~
|  |                              Send Abort
|  |All-1 & w=expect & MIC wrong     
|  |~~~~~~~~~~~~~~~~~~~~~~~~~~~~      +-+  All-1       
|  |set local_Bitmap(FCN)             | v  ~~~~~~~~~~  
|  |send local_Bitmap     +===========+==+ snd lcl_btmp
|  +--------------------->+   Wait End   +-+           
|                         +=====+=+====+=+ | w=expct &  
|       w=expected & MIC right  | |    ^   | MIC wrong 
|       ~~~~~~~~~~~~~~~~~~~~~~  | |    +---+ ~~~~~~~~~ 
|        set local_Bitmap(FCN)  | | set lcl_Bitmap(FCN)
|                               | |                    
|All-1 & w=expected & MIC right | +-->* ABORT          
|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ v                      
|set local_Bitmap(FCN)        +=+==========+           
+---------------------------->+     END    |
                              +============+   
            --->* Only Uplink
                 ABORT
                 ~~~~~~~~
                 Inactivity_Timer = expires                                                      
]]></artwork></figure>

</section>
<section anchor="note" title="Note">
<t>Carles Gomez has been funded in part by the Spanish Government
(Ministerio de Educacion, Cultura y Deporte) through the Jose
Castillejo grant CAS15/00336, and by the ERDF and the Spanish Government 
through project TEC2016-79988-P.  Part of his contribution to this work
has been carried out during his stay as a visiting scholar at the
Computer Laboratory of the University of Cambridge.</t>

</section>


  </back>

<!-- ##markdown-source:
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
cXk6q0bn5U72/wE2E2W7essBAA==

-->

</rfc>

